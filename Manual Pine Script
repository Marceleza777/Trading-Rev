Pine Script™ v5 User Manual TradingView 
Dec 29, 2023
CONTENTS 
1 Welcome to Pine Script™ v5 1 
2 Pine Script™ primer 3 2.1 First steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 2.1.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 2.1.2 Using scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 2.1.3 Reading scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 2.1.4 Writing scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 2.2 First indicator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 2.2.1 The Pine Editor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 2.2.2 First version . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 2.2.3 Second version . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 2.2.4 Next . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 2.3 Next steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 2.3.1 “indicators” vs “strategies” . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 2.3.2 How scripts are executed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 2.3.3 Time series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 2.3.4 Publishing scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 2.3.5 Getting around the Pine Script™ documentation . . . . . . . . . . . . . . . . . . . . . . . . 14 2.3.6 Where to go from here? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 
3 Language 15 3.1 Execution model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 3.1.1 Calculation based on historical bars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 3.1.2 Calculation based on realtime bars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 3.1.3 Events triggering the execution of a script . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 3.1.4 More information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 3.1.5 Historical values of functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 3.2 Time series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 3.3 Script structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 3.3.1 Version . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 3.3.2 Declaration statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 3.3.3 Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 3.3.4 Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 3.3.5 Line wrapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 3.3.6 Compiler annotations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 3.4 Identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 3.5 Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 3.5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 3.5.2 Arithmetic operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 
i
3.5.3 Comparison operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 3.5.4 Logical operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 3.5.5 `?:` ternary operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 3.5.6 `[ ]` history-referencing operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 3.5.7 Operator precedence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 3.5.8 `=` assignement operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 3.5.9 `:=` reassignement operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 
3.6 Variable declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 3.6.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 3.6.2 Variable reassignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 3.6.3 Declaration modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 
3.7 Conditional structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 3.7.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 3.7.2 `if` structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 3.7.3 `switch` structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 3.7.4 Matching local block type requirement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 
3.8 Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47 3.8.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47 3.8.2 `for` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 3.8.3 `while` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 
3.9 Type system . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 3.9.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 3.9.2 Qualifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 3.9.3 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 3.9.4 `na` value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 3.9.5 Type templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65 3.9.6 Type casting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66 3.9.7 Tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 
3.10 Built-ins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 3.10.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 3.10.2 Built-in variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 3.10.3 Built-in functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 
3.11 User-defined functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 3.11.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74 3.11.2 Single-line functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74 3.11.3 Multi-line functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 3.11.4 Scopes in the script . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 3.11.5 Functions that return multiple results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 3.11.6 Limitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 
3.12 Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 3.12.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 3.12.2 Creating objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 3.12.3 Changing field values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 3.12.4 Collecting objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 3.12.5 Copying objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 3.12.6 Shadowing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82 
3.13 Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 3.13.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 3.13.2 Built-in methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 3.13.3 User-defined methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85 3.13.4 Method overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88 3.13.5 Advanced example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90 
3.14 Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94 3.14.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94 
ii
3.14.2 Declaring arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95 3.14.3 Reading and writing array elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 3.14.4 Looping through array elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99 3.14.5 Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100 3.14.6 History referencing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101 3.14.7 Inserting and removing array elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101 3.14.8 Calculations on arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 3.14.9 Manipulating arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 3.14.10 Searching arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109 3.14.11 Error handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109 
3.15 Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 3.15.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 3.15.2 Declaring a matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 3.15.3 Reading and writing matrix elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114 3.15.4 Rows and columns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116 3.15.5 Looping through a matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122 3.15.6 Copying a matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125 3.15.7 Scope and history . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130 3.15.8 Inspecting a matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132 3.15.9 Manipulating a matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134 3.15.10 Matrix calculations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141 3.15.11 Error handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151 
3.16 Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154 3.16.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155 3.16.2 Declaring a map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155 3.16.3 Reading and writing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157 3.16.4 Looping through a map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165 3.16.5 Copying a map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168 3.16.6 Scope and history . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170 3.16.7 Maps of other collections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172 
4 Concepts 175 4.1 Alerts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175 4.1.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175 4.1.2 Script alerts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177 4.1.3 `alertcondition()` events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181 4.1.4 Avoiding repainting with alerts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184 4.2 Backgrounds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185 4.3 Bar coloring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188 4.4 Bar plotting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189 4.4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189 4.4.2 Plotting candles with `plotcandle()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189 4.4.3 Plotting bars with `plotbar()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192 4.5 Bar states . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192 4.5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193 4.5.2 Bar state built-in variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193 4.5.3 Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195 4.6 Chart information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197 4.6.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197 4.6.2 Prices and volume . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198 4.6.3 Symbol information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198 4.6.4 Chart timeframe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200 4.6.5 Session information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200 4.7 Colors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201 
iii
4.7.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201 4.7.2 Constant colors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202 4.7.3 Conditional coloring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203 4.7.4 Calculated colors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205 4.7.5 Mixing transparencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209 4.7.6 Tips . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211 
4.8 Fills . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214 4.8.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215 4.8.2 `plot()` and `hline()` fills . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215 4.8.3 Line fills . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217 
4.9 Inputs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218 4.9.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219 4.9.2 Input functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220 4.9.3 Input function parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220 4.9.4 Input types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221 4.9.5 Other features affecting Inputs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230 4.9.6 Tips . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230 
4.10 Levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232 4.10.1 `hline()` levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232 4.10.2 Fills between levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233 
4.11 Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234 4.11.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235 4.11.2 Creating a library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235 4.11.3 Publishing a library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239 4.11.4 Using a library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241 
4.12 Lines and boxes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242 4.12.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242 4.12.2 Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243 4.12.3 Boxes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253 4.12.4 Polylines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264 4.12.5 Realtime behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275 4.12.6 Limitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276 
4.13 Non-standard charts data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278 4.13.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278 4.13.2 `ticker.heikinashi()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278 4.13.3 `ticker.renko()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281 4.13.4 `ticker.linebreak()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281 4.13.5 `ticker.kagi()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281 4.13.6 `ticker.pointfigure()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281 
4.14 Other timeframes and data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282 4.14.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282 4.14.2 Common characteristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284 4.14.3 Data feeds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290 4.14.4 `request.security()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291 4.14.5 `request.security_lower_tf()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306 4.14.6 Custom contexts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313 4.14.7 Historical and realtime behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 317 4.14.8 `request.currency_rate()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322 4.14.9 `request.dividends()`, `request.splits()`, and `request.earnings()` . . . . . . . . . . . . . . . . . 323 4.14.10 `request.quandl()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 326 4.14.11 `request.financial()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327 4.14.12 `request.economic()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336 4.14.13 `request.seed()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 348 4.15 Plots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350 
iv
4.15.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350 4.15.2 `plot()` parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352 4.15.3 Plotting conditionally . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355 4.15.4 Levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 358 4.15.5 Offsets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359 4.15.6 Plot count limit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359 4.15.7 Scale . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360 
4.16 Repainting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362 4.16.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362 4.16.2 Historical vs realtime calculations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364 4.16.3 Plotting in the past . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 369 4.16.4 Dataset variations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 370 
4.17 Sessions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 371 4.17.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 371 4.17.2 Session strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372 4.17.3 Session states . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 374 4.17.4 Using sessions with `request.security()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 374 
4.18 Strategies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 376 4.18.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 376 4.18.2 A simple strategy example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377 4.18.3 Applying a strategy to a chart . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377 4.18.4 Strategy tester . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 378 4.18.5 Broker emulator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 381 4.18.6 Orders and entries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 384 4.18.7 Position sizing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406 4.18.8 Closing a market position . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408 4.18.9 OCA groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 410 4.18.10 Currency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414 4.18.11 Altering calculation behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 415 4.18.12 Simulating trading costs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 419 4.18.13 Risk management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 425 4.18.14 Margin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 426 4.18.15 Strategy Alerts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 427 4.18.16 Notes on testing strategies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 430 
4.19 Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 431 4.19.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 431 4.19.2 Creating tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 432 4.19.3 Tips . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 438 
4.20 Text and shapes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 439 4.20.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 439 4.20.2 `plotchar()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 441 4.20.3 `plotshape()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 443 4.20.4 `plotarrow()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 445 4.20.5 Labels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447 
4.21 Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 455 4.21.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 456 4.21.2 Time variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 459 4.21.3 Time functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 461 4.21.4 Formatting dates and time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 464 
4.22 Timeframes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 466 4.22.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 466 4.22.2 Timeframe string specifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467 4.22.3 Comparing timeframes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467 
v
5 Writing scripts 469 5.1 Style guide . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469 5.1.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469 5.1.2 Naming Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 470 5.1.3 Script organization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 470 5.1.4 Spacing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 474 5.1.5 Line wrapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 474 5.1.6 Vertical alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 474 5.1.7 Explicit typing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 475 5.2 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 475 5.2.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 475 5.2.2 The lay of the land . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 476 5.2.3 Displaying numeric values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 477 5.2.4 Displaying strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 478 5.2.5 Debugging conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 480 5.2.6 Debugging from inside functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482 5.2.7 Debugging from inside `for` loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 483 5.2.8 Tips . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487 5.3 Publishing scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 488 5.3.1 Script visibility and access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 488 5.3.2 Preparing a publication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491 5.3.3 Publishing a script . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493 5.3.4 Updating a publication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493 5.4 Limitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 495 5.4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 495 5.4.2 Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 495 5.4.3 Chart visuals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 496 5.4.4 `request.*()` calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 500 5.4.5 Script size and memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 502 5.4.6 Other limitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 504 
6 FAQ 507 6.1 Get real OHLC price on a Heikin Ashi chart . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 507 6.2 Get non-standard OHLC values on a standard chart . . . . . . . . . . . . . . . . . . . . . . . . . . . 508 6.3 Plot arrows on the chart . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 508 6.4 Plot a dynamic horizontal line . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 509 6.5 Plot a vertical line on condition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 509 6.6 Access the previous value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 510 6.7 Get a 5-days high . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 510 6.8 Count bars in a dataset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 511 6.9 Enumerate bars in a day . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 511 6.10 Find the highest and lowest values for the entire dataset . . . . . . . . . . . . . . . . . . . . . . . . . 511 6.11 Query the last non-na value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 512 
7 Error messages 513 7.1 The if statement is too long . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 513 7.2 Script requesting too many securities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 513 7.3 Script could not be translated from: null . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 514 7.4 line 2: no viable alternative at character ‘$’ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 514 7.5 Mismatched input <…> expecting <???> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 514 7.6 Loop is too long (> 500 ms) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 515 7.7 Script has too many local variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 516 7.8 Pine Script™ cannot determine the referencing length of a series. Try using max_bars_back in the 
indicator or strategy function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 516 vi
8 Release notes 519 8.1 2023 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 519 8.1.1 December 2023 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 519 8.1.2 November 2023 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 520 8.1.3 October 2023 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 520 8.1.4 September 2023 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 520 8.1.5 August 2023 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521 8.1.6 July 2023 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521 8.1.7 June 2023 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 522 8.1.8 May 2023 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 522 8.1.9 April 2023 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 522 8.1.10 March 2023 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 522 8.1.11 February 2023 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 523 8.1.12 January 2023 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 523 8.2 2022 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 523 8.2.1 December 2022 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 523 8.2.2 November 2022 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 523 8.2.3 October 2022 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 524 8.2.4 September 2022 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 524 8.2.5 August 2022 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 524 8.2.6 July 2022 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 525 8.2.7 June 2022 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 525 8.2.8 May 2022 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526 8.2.9 April 2022 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 527 8.2.10 March 2022 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529 8.2.11 February 2022 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530 8.2.12 January 2022 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530 8.3 2021 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530 8.3.1 December 2021 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530 8.3.2 November 2021 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 532 8.3.3 October 2021 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 533 8.3.4 September 2021 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 535 8.3.5 July 2021 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 535 8.3.6 June 2021 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 535 8.3.7 May 2021 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 535 8.3.8 April 2021 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 536 8.3.9 March 2021 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 537 8.3.10 February 2021 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 537 8.3.11 January 2021 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538 8.4 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538 8.4.1 December 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538 8.4.2 November 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539 8.4.3 October 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539 8.4.4 September 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539 8.4.5 August 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 541 8.4.6 July 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 541 8.4.7 June 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 541 8.4.8 May 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 544 8.4.9 April 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 544 8.4.10 March 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 544 8.4.11 February 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 544 8.4.12 January 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 545 8.5 2019 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 545 8.5.1 December 2019 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 545 
vii
8.5.2 October 2019 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 545 8.5.3 September 2019 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 546 8.5.4 July-August 2019 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 546 8.5.5 June 2019 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547 
8.6 2018 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547 8.6.1 October 2018 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547 8.6.2 April 2018 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547 
8.7 2017 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547 8.7.1 August 2017 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547 8.7.2 June 2017 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547 8.7.3 May 2017 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 548 8.7.4 April 2017 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 548 8.7.5 March 2017 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 548 8.7.6 February 2017 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 548 
8.8 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549 8.8.1 December 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549 8.8.2 October 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549 8.8.3 September 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549 8.8.4 July 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549 8.8.5 March 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549 8.8.6 February 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549 8.8.7 January 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549 
8.9 2015 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 550 8.9.1 October 2015 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 550 8.9.2 September 2015 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 550 8.9.3 July 2015 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 550 8.9.4 June 2015 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 550 8.9.5 April 2015 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 550 8.9.6 March 2015 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 550 8.9.7 February 2015 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 550 
8.10 2014 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 551 8.10.1 August 2014 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 551 8.10.2 July 2014 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 551 8.10.3 June 2014 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 551 8.10.4 April 2014 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 551 8.10.5 February 2014 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 551 8.11 2013 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 552 
9 Migration guides 553 9.1 To Pine Script™ version 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 553 9.1.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 554 9.1.2 v4 to v5 converter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 554 9.1.3 Renamed functions and variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 555 9.1.4 Renamed function parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 555 9.1.5 Removed an `rsi()` overload . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 556 9.1.6 Reserved keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 556 9.1.7 Removed `iff()` and `offset()` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 556 9.1.8 Split of `input()` into several functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557 9.1.9 Some function parameters now require built-in arguments . . . . . . . . . . . . . . . . . . . 557 9.1.10 Deprecated the `transp` parameter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 558 9.1.11 Changed the default session days for `time()` and `time_close()` . . . . . . . . . . . . . . . . 559 9.1.12 `strategy.exit()` now must do something . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 559 9.1.13 Common script conversion errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 559 9.1.14 All variable, function, and parameter name changes . . . . . . . . . . . . . . . . . . . . . . 561 
viii
9.2 To Pine Script™ version 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 564 9.2.1 Converter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 565 9.2.2 Renaming of built-in constants, variables, and functions . . . . . . . . . . . . . . . . . . . . 565 9.2.3 Explicit variable type declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 566 
9.3 To Pine Script™ version 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 566 9.3.1 Default behaviour of security function has changed . . . . . . . . . . . . . . . . . . . . . . . 566 9.3.2 Self-referenced variables are removed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 567 9.3.3 Forward-referenced variables are removed . . . . . . . . . . . . . . . . . . . . . . . . . . . 568 9.3.4 Resolving a problem with a mutable variable in a security expression . . . . . . . . . . . . . . 568 9.3.5 Math operations with booleans are forbidden . . . . . . . . . . . . . . . . . . . . . . . . . . 568 
10 Where can I get more information? 571 10.1 External resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 571 10.2 Download this manual . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 571 
ix
x
CHAPTER 
ONE 
WELCOME TO PINE SCRIPT™ V5 
  
Pine Script™ is TradingView’s programming language. It allows traders to create their own trading tools and run them on our servers. We designed Pine Script™ as a lightweight, yet powerful, language for developing indicators and strategies that you can then backtest. Most of TradingView’s built-in indicators are written in Pine Script™, and our thriving community of Pine Script™ programmers has published more than 100,000 Community Scripts. 
It’s our explicit goal to keep Pine Script™ accessible and easy to understand for the broadest possible audience. Pine Script™ is cloud-based and therefore different from client-side programming languages. While we likely won’t develop Pine Script™ into a full-fledged language, we do constantly improve it and are always happy to consider requests for new features. 
Because each script uses computational resources in the cloud, we must impose limits in order to share these resources fairly among our users. We strive to set as few limits as possible, but will of course have to implement as many as needed for the platform to run smoothly. Limitations apply to the amount of data requested from additional symbols, execution time, memory usage and script size. 
  

1
Pine Script™ v5 User Manual 
2 Chapter 1. Welcome to Pine Script™ v5
2.1 First steps 
CHAPTER 
TWO 
PINE SCRIPT™ PRIMER   


• Introduction 
• Using scripts 
• Reading scripts 
• Writing scripts
	



2.1.1 Introduction 
Welcome to the Pine Script™ v5 User Manual, which will accompany you in your journey to learn to program your own trading tools in Pine Script™. Welcome also to the very active community of Pine Script™ programmers on TradingView. 
In this page, we present a step-by-step approach that you can follow to gradually become more familiar with indicators and strategies (also called scripts) written in the Pine Script™ programming language on TradingView. We will get you started on your journey to: 
1. Use some of the tens of thousands of existing scripts on the platform. 
2. Read the Pine Script™ code of existing scripts. 
3. Write Pine Script™ scripts. 
If you are already familiar with the use of Pine scripts on TradingView and are now ready to learn how to write your own, then jump to the Writing scripts section of this page. 
If you are new to our platform, then please read on! 
3
Pine Script™ v5 User Manual 
2.1.2 Using scripts 
If you are interested in using technical indicators or strategies on TradingView, you can first start exploring the thousands of indicators already available on our platform. You can access existing indicators on the platform in two different ways: 
• By using the chart’s “Indicators & Strategies” button, or 
• By browsing TradingView’s Community Scripts, the largest repository of trading scripts in the world, with more than 100,000 scripts, most of which are free and open-source, which means you can see their Pine Script™ code. 
If you can find the tools you need already written for you, it can be a good way to get started and gradually become proficient as a script user, until you are ready to start your programming journey in Pine Script™. 
Loading scripts from the chart 
To explore and load scripts from you chart, use the “Indicators & Strategies” button: 
  
The dialog box presents different categories of scripts in its left pane: 
• Favorites lists the scripts you have “favorited” by clicking on the star that appears to the left of its name when you mouse over it. 
• My scripts displays the scipts you have written and saved in the Pine Editor. They are saved in TradingView’s cloud. 
• Built-ins groups all TradingVIew built-ins organized in four categories: indicators, strategies, candlestick patterns and volume profiles. Most are written in Pine Script™ and available for free. 
• Community Scripts is where you can search from the 100,000+ published scripts written by TradingView users. • Invite-only scripts contains the list of the invite-only scripts you have been granted access to by their authors. Here, the section containing the TradingView built-ins is selected: 
4 Chapter 2. Pine Script™ primer
Pine Script™ v5 User Manual 
  

When you click on one of the indicators or strategies (the ones with the green and red arrows following their name), it loads on your chart. 
Browsing Community Scripts 
From TradingView’s homepage, you can bring up the Community Scripts stream from the “Community” menu. Here, we are pointing to the “Editors’ Picks” section, but there are many other categories you can choose from: 
  

You can also search for scripts using the homepage’s “Search” field, and filter scripts using different criteria. The Help Center has a page explaining the different types of scripts that are available. 
The scripts stream shows script widgets, i.e., placeholders showing a miniature view of each publication’s chart and de scription, and its author. By clicking on it you will open the script’s page, where you can see the script on a chart, read the author’s description, like the script, leave comments or read the script’s source code if it was published open-source. 
Once you find an interesting script in the Community Scripts, follow the instructions in the Help Center to load it on your chart. 
2.1. First steps 5
Pine Script™ v5 User Manual 
Changing script settings 
Once a script is loaded on the chart, you can double-click on its name (#1) to bring up its “Settings/Inputs” tab (#2):   
The “Inputs” tab allows you to change the settings which the script’s author has decided to make editable. You can configure some of the script’s visuals using the “Style” tab of the same dialog box, and which timeframes the script should appear on using the “Visibility” tab. 
Other settings are available to all scripts from the buttons that appear to the right of its name when you mouse over it, and from the “More” menu (the three dots): 
  
6 Chapter 2. Pine Script™ primer
Pine Script™ v5 User Manual 
2.1.3 Reading scripts 
Reading code written by good programmers is the best way to develop your understanding of the language. This is as true for Pine Script™ as it is for all other programming languages. Finding good open-source Pine Script™ code is relatively easy. These are reliable sources of code written by good programmers on TradingView: 
• The TradingView built-in indicators 
• Scripts selected as Editors’ Picks 
• Scripts by the authors the PineCoders account follows 
• Many scripts by authors with high reputation and open-source publications. 
Reading code from Community Scripts is easy; if you don’t see a grey or red “lock” icon in the upper-right corner of the script’s widget, this indicates the script is open-source. By opening its script page, you will be able to see its source. 
To see the code of TradingView built-ins, load the indicator on your chart, then hover over its name and select the “Source code” curly braces icon (if you don’t see it, it’s because the indicator’s source is unavailable). When you click on the icon, the Pine Editor will open and from there, you can see the script’s code. If you want to play with it, you will need to use the Editor’s “More” menu button at the top-right of the Editor’s pane, and select “Make a copy…”. You will then be able to modify and save the code. Because you will have created a different version of the script, you will need to use the Editor’s “Add to Chart” button to add that new copy to the chart. 
This shows the Pine Editor having just opened after we selected the “View source” button from the indicator on our chart. We are about to make a copy of its source because it is read-only for now (indicated by the “lock” icon near its filename in the Editor): 
  

You can also open TradingView built-in indicators from the Pine Editor (accessible from the “Pine Editor” tab at the bottom of the chart) by using the “Open/New default built-in script…” menu selection. 
2.1. First steps 7
Pine Script™ v5 User Manual 
2.1.4 Writing scripts 
We have built Pine Script™ to empower both budding and seasoned traders to create their own trading tools. We have designed it so it is relatively easy to learn for first-time programmers — although learning a first programming language, like trading, is rarely very easy for anyone — yet powerful enough for knowledgeable programmers to build tools of moderate complexity. 
Pine Script™ allows you to write three types of scripts: 
• Indicators like RSI, MACD, etc. 
• Strategies which include logic to issue trading orders and can be backtested and forward-tested. 
• Libraries which are used by more advanced programmers to package oft-used functions that can be reused by other scripts. 
The next step we recommend is to write your first indicator. 
  

  

2.2 First indicator 
• The Pine Editor 
• First version 
• Second version 
• Next
	



2.2.1 The Pine Editor 
The Pine Editor is where you will be working on your scripts. While you can use any text editor you want to write your Pine scripts, using our Editor has many advantages: 
• It highlights your code following Pine Script™ syntax. 
• It pops up syntax reminders for built-in and library functions when you hover over them. 
• It provides quick access to the Pine Script™ v5 Reference Manual popup when you ctrl + click / cmd + click on Pine Script™ keywords. 
• It provides an auto-complete feature that you can activate with ctrl + space / cmd + space. 
• It makes the write/compile/run cycle fast because saving a new version of a script loaded on the chart also executes it immediately. 
• While not as feature-rich as the top editors out there, it provides key functionality such as search and replace, multi-cursor and versioning. 
8 Chapter 2. Pine Script™ primer
Pine Script™ v5 User Manual 
To open the Editor, click on the “Pine Editor” tab at the bottom of your TradingView chart. This will open up the Editor’s pane. 
2.2.2 First version 
We will now create our first working Pine script, an implementation of the MACD indicator in Pine Script™: 
1 //@version=5 
2 indicator("MACD #1") 
3 fast = 12 
4 slow = 26 
5 fastMA = ta.ema(close, fast) 
6 slowMA = ta.ema(close, slow) 
7 macd = fastMA - slowMA 
8 signal = ta.ema(macd, 9) 
9 plot(macd, color = color.blue) 
10 plot(signal, color = color.orange) 
• Start by bringing up the “Open” dropdown menu at the top right of the Editor and choose “New blank indicator”. • Then copy the example script above, taking care not to include the line numbers in your selection. • Select all the code already in the editor and replace it with the example script. 
• Click “Save” and choose a name for your script. Your script is now saved in TradingView’s cloud, but under your account’s name. Nobody but you can use it. 
• Click “Add to Chart” in the Editor’s menu bar. The MACD indicator appears in a separate Pane under your chart. Your first Pine script is running on your chart, which should look like this: 
  
Let’s look at our script’s code, line by line: 
2.2. First indicator 9
Pine Script™ v5 User Manual 
Line 1: //@version=5 
This is a compiler annotation telling the compiler the script will use version 5 of Pine Script™. 
Line 2: indicator("MACD #1") 
Defines the name of the script that will appear on the chart as “MACD”. 
Line 3: fast = 12 
Defines a fast integer variable which will be the length of the fast EMA. 
Line 4: slow = 26 
Defines a slow integer variable which will be the length of the slow EMA. 
Line 5: fastMA = ta.ema(close, fast) 
Defines the variable fastMA, containing the result of the EMA calculation (Exponential Moving Average) with a length equal to fast (12), on the close series, i.e., the closing price of bars. 
Line 6: slowMA = ta.ema(close, slow) 
Defines the variable slowMA, containing the result of the EMA calculation with a length equal to slow (26), from close. 
Line 7: macd = fastMA - slowMA 
Defines the variable macd as the difference between the two EMAs. 
Line 8: signal = ta.ema(macd, 9) 
Defines the variable signal as a smoothed value of macd using the EMA algorithm (Exponential Moving Av erage) with a length of 9. 
Line 9: plot(macd, color = color.blue) 
Calls the plot function to output the variable macd using a blue line. 
Line 10: plot(signal, color = color.orange) 
Calls the plot function to output the variable signal using an orange line. 
2.2.3 Second version 
The first version of our script calculated MACD “manually”, but because Pine Script™ is designed to write indicators and strategies, built-in Pine Script™ functions exist for many common indicators, including one for… MACD: ta.macd(). 
This is the second version of our script: 
1 //@version=5 
2 indicator("MACD #2") 
3 fastInput = input(12, "Fast length") 
4 slowInput = input(26, "Slow length") 
5 [macdLine, signalLine, histLine] = ta.macd(close, fastInput, slowInput, 9) 6 plot(macdLine, color = color.blue) 
7 plot(signalLine, color = color.orange) 
Note that we have: 
• Added inputs so we can change the lengths for the MAs 
• We now use the ta.macd() built-in to calculate our MACD, which saves us three line and makes our code easier to read. 
Let’s repeat the same process as before to copy that code in a new indicator: 
• Start by bringing up the “Open” dropdown menu at the top right of the Editor and choose “New blank indicator”. • Then copy the example script above, again taking care not to include the line numbers in your selection. • Select all the code already in the editor and replace it with the second version of our script. 
10 Chapter 2. Pine Script™ primer
Pine Script™ v5 User Manual 
• Click “Save” and choose a name for your script different than the previous one. 
• Click “Add to Chart” in the Editor’s menu bar. The “MACD #2” indicator appears in a separate Pane under the “MACD #1” indicator. 
Your second Pine script is running on your chart. If you double-click on the indicator’s name on your chart, you will bring up the script’s “Settings/Inputs” tab, where you can now change the slow and fast lengths: 
  
Let’s look at the lines that have changed in the second version of our script: 
Line 2: indicator("MACD #2") 
We have changed #1 to #2 so the second version of our indicator displays a different name on the chart. 
Line 3: fastInput = input(12, "Fast length") 
Instead of assigning a constant value to a variable, we have used the input() function so we can change the value in our script’s “Settings/Inputs” tab. 12 will be the default value and the field’s label will be "Fast length". If the value is changed in the “Inputs” tab, the fastInput variable’s content will contain the new value and the script will re-execute on the chart with that new value. Note that, as our Pine Script™ Style Guide recommends, we add Input to the end of the variable’s name to remind us, later in the script, that its value comes from a user input. 
Line 4: slowInput = input(26, "Slow length") 
We do the same for the slow length, taking care to use a different variable name, default value and text string for the field’s label. 
Line 5: [macdLine, signalLine, histLine] = ta.macd(close, fastInput, slowInput, 9)This is where we call the ta.macd() built-in to perform all the first version’s calculations in one line only. The function requires four parameters (the values after the function name, enclosed in parentheses). It returns three values into the three variables instead of only one, like the functions we used until now, which is why we need to enclose the list of three variables receiving the function’s result in square brackets, to the left of the = sign. Note that two of the values we pass to the function are the “input” variables containing the fast and slow lengths: fastInput and slowInput. 
Line 6 and 7: 
2.2. First indicator 11
Pine Script™ v5 User Manual 
The variable names we are plotting there have changed, but the lines are doing the same thing as in our first version. 
Our second version performs the same calculations as our first, but we can change the two lengths used to calculate it. Our code is also simpler and shorter by three lines. We have improved our script. 
2.2.4 Next 
We now recommend you go to our Next Steps page. 
  

  

2.3 Next steps 
• “indicators” vs “strategies” 
• How scripts are executed 
• Time series 
• Publishing scripts 
• Getting around the Pine Script™ documentation 
• Where to go from here?
	



After your first steps and your first indicator, let us explore a bit more of the Pine Script™ landscape by sharing some pointers to guide you in your journey to learn Pine Script™. 
2.3.1 “indicators” vs “strategies” 
Pine Script™ strategies are used to backtest on historical data and forward test on open markets. In addition to indicator calculations, they contain strategy.*() calls to send trade orders to Pine Script™’s broker emulator, which can then simulate their execution. Strategies display backtest results in the “Strategy Tester” tab at the bottom of the chart, next to the “Pine Editor” tab. 
Pine Script™ indicators also contain calculations, but cannot be used in backtesting. Because they do not require the broker emulator, they use less resources and will run faster. It is thus advantageous to use indicators whenever you can. 
Both indicators and strategies can run in either overlay mode (over the chart’s bars) or pane mode (in a separate section below or above the chart). Both can also plot information in their respective space, and both can generate alert events. 
12 Chapter 2. Pine Script™ primer
Pine Script™ v5 User Manual 
2.3.2 How scripts are executed 
A Pine script is not like programs in many programming languages that execute once and then stop. In the Pine Script™ runtime environment, a script runs in the equivalent of an invisible loop where it is executed once on each bar of whatever chart you are on, from left to right. Chart bars that have already closed when the script executes on them are called historical bars. When execution reaches the chart’s last bar and the market is open, it is on the realtime bar. The script then executes once every time a price or volume change is detected, and one last time for that realtime bar when it closes. That realtime bar then becomes an elapsed realtime bar. Note that when the script executes in realtime, it does not recalculate on all the chart’s historical bars on every price/volume update. It has already calculated once on those bars, so it does not need to recalculate them on every chart tick. See the Execution model page for more information. 
When a script executes on a historical bar, the close built-in variable holds the value of that bar’s close. When a script executes on the realtime bar, close returns the current price of the symbol until the bar closes. 
Contrary to indicators, strategies normally execute only once on realtime bars, when they close. They can also be config ured to execute on each price/volume update if that is what you need. See the page on Strategies for more information, and to understand how strategies calculate differently than indicators. 
2.3.3 Time series 
The main data structure used in Pine Script™ is called a time series. Time series contain one value for each bar the script executes on, so they continuously expand as the script executes on more bars. Past values of the time series can be referenced using the history-referencing operator: []. close[1], for example, refers to the value of close on the bar preceding the one where the script is executing. 
While this indexing mechanism may remind many programmers of arrays, a time series is different and thinking in terms of arrays will be detrimental to understanding this key Pine Script™ concept. A good comprehension of both the execution model and time series is essential in understanding how Pine scripts work. If you have never worked with data organized in time series before, you will need practice to put them to work for you. Once you familiarize yourself with these key concepts, you will discover that by combining the use of time series with our built-in functions specifically designed to handle them efficiently, much can be accomplished in very few lines of code. 
2.3.4 Publishing scripts 
TradingView is home to a large community of Pine Script™ programmers and millions of traders from all around the world. Once you become proficient enough in Pine Script™, you can choose to share your scripts with other traders. Before doing so, please take the time to learn Pine Script™ well-enough to supply traders with an original and reliable tool. All publicly published scripts are analyzed by our team of moderators and must comply with our Script Publishing Rules, which require them to be original and well-documented. 
If want to use Pine scripts for your own use, simply write them in the Pine Editor and add them to your chart from there; you don’t have to publish them to use them. If you want to share your scripts with just a few friends, you can publish them privately and send your friends the browser’s link to your private publication. See the page on Publishing for more information. 
2.3. Next steps 13
Pine Script™ v5 User Manual 
2.3.5 Getting around the Pine Script™ documentation 
While reading code from published scripts is no doubt useful, spending time in our documentation will be necessary to attain any degree of proficiency in Pine Script™. Our two main sources of documentation on Pine Script™ are: 
• This Pine Script™ v5 User Manual 
• Our Pine Script™ v5 Reference Manual 
The Pine Script™ v5 User Manual is in HTML format and in English only. 
The Pine Script™ v5 Reference Manual documents what each variable, function or keyword does. It is an essential tool for all Pine Script™ programmers; your life will be miserable if you try to write scripts of any reasonable complexity without consulting it. It exists in two formats: the HTML format we just linked to, and the popup version, which can be accessed from the Pine Editor, by either ctrl + clicking on a keyword, or by using the Editor’s “More/Pine Script™ reference (pop-up)” menu. The Reference Manual is translated in other languages. 
There are five different versions of Pine Script™. Ensure the documentation you use corresponds to the Pine Script™ version you are coding with. 
2.3.6 Where to go from here? 
This Pine Script™ v5 User Manual contains numerous examples of code used to illustrate the concepts we discuss. By going through it, you will be able to both learn the foundations of Pine Script™ and study the example scripts. Reading about key concepts and trying them out right away with real code is a productive way to learn any programming language. As you hopefully have already done in the First indicator page, copy this documentation’s examples in the Editor and play with them. Explore! You won’t break anything. 
This is how the Pine Script™ v5 User Manual you are reading is organized: 
• The Language section explains the main components of the Pine Script™ language and how scripts execute. • The Concepts section is more task-oriented. It explains how to do things in Pine Script™. • The Writing section explores tools and tricks that will help you write and publish scripts. • The FAQ section answers common questions from Pine Script™ programmers. 
• The Error messages page documents causes and fixes for the most common runtime and compiler errors. • The Release Notes page is where you can follow the frequent updates to Pine Script™. 
• The Migration guides section explains how to port between different versions of Pine Script™. 
• The Where can I get more information page lists other useful Pine Script™-related content, including where to ask questions when you are stuck on code. 
We wish you a successful journey with Pine Script™… and trading! 

14 Chapter 2. Pine Script™ primer
CHAPTER 
THREE 
LANGUAGE 

3.1 Execution model 
• Calculation based on historical bars 
• Calculation based on realtime bars 
• Events triggering the execution of a script 
• More information 
• Historical values of functions
	



The execution model of the Pine Script™ runtime is intimately linked to Pine Script™’s time series and type system. Understanding all three is key to making the most of the power of Pine Script™. 
The execution model determines how your script is executed on charts, and thus how the code you write in scripts works. Your code would do nothing were it not for Pine Script™’s runtime, which kicks in after your code has compiled and it is executed on your chart because one of the events triggering the execution of a script has occurred. 
When a Pine script is loaded on a chart it executes once on each historical bar using the available OHLCV (open, high, low, close, volume) values for each bar. Once the script’s execution reaches the rightmost bar in the dataset, if trading is currently active on the chart’s symbol, then Pine Script™ indicators will execute once every time an update occurs, i.e., price or volume changes. Pine Script™ strategies will by default only execute when the rightmost bar closes, but they can also be configured to execute on every update, like indicators do. 
All symbol/timeframe pairs have a dataset comprising a limited number of bars. When you scroll a chart to the left to see the dataset’s earlier bars, the corresponding bars are loaded on the chart. The loading process stops when there are no more bars for that particular symbol/timeframe pair or the maximum number of bars your account type permits has been loaded. You can scroll the chart to the left until the very first bar of the dataset, which has an index value of 0 (see bar_index). 
When the script first runs on a chart, all bars in a dataset are historical bars, except the rightmost one if a trading session is active. When trading is active on the rightmost bar, it is called the realtime bar. The realtime bar updates when a price 
15
Pine Script™ v5 User Manual 
or volume change is detected. When the realtime bar closes, it becomes an elapsed realtime bar and a new realtime bar opens. 
3.1.1 Calculation based on historical bars 
Let’s take a simple script and follow its execution on historical bars: 
1 //@version=5 
2 indicator("My Script", overlay = true) 
3 src = close 
4 a = ta.sma(src, 5) 
5 b = ta.sma(src, 50) 
6 c = ta.cross(a, b) 
7 plot(a, color = color.blue) 
8 plot(b, color = color.black) 
9 plotshape(c, color = color.red) 
On historical bars, a script executes at the equivalent of the bar’s close, when the OHLCV values are all known for that bar. Prior to execution of the script on a bar, the built-in variables such as open, high, low, close, volume and time are set to values corresponding to those from that bar. A script executes once per historical bar. 
Our example script is first executed on the very first bar of the dataset at index 0. Each statement is executed using the values for the current bar. Accordingly, on the first bar of the dataset, the following statement: 
src = close 
initializes the variable src with the close value for that first bar, and each of the next lines is executed in turn. Because the script only executes once for each historical bar, the script will always calculate using the same close value for a specific historical bar. 
The execution of each line in the script produces calculations which in turn generate the indicator’s output values, which can then be plotted on the chart. Our example uses the plot and plotshape calls at the end of the script to output some values. In the case of a strategy, the outcome of the calculations can be used to plot values or dictate the orders to be placed. 
After execution and plotting on the first bar, the script is executed on the dataset’s second bar, which has an index of 1. The process then repeats until all historical bars in the dataset are processed and the script reaches the rightmost bar on the chart. 
16 Chapter 3. Language
Pine Script™ v5 User Manual 

3.1.2 Calculation based on realtime bars 
The behavior of a Pine script on the realtime bar is very different than on historical bars. Recall that the realtime bar is the rightmost bar on the chart when trading is active on the chart’s symbol. Also, recall that strategies can be have in two different ways in the realtime bar. By default, they only execute when the realtime bar closes, but the calc_on_every_tick parameter of the strategy declaration statement can be set to true to modify the strat egy’s behavior so that it executes each time the realtime bar updates, as indicators do. The behavior described here for indicators will thus only apply to strategies using calc_on_every_tick=true. 
The most important difference between execution of scripts on historical and realtime bars is that while they execute only once on historical bars, scripts execute every time an update occurs during a realtime bar. This entails that built-in variables such as high, low and close which never change on a historical bar, can change at each of a script’s iteration in the realtime bar. Changes in the built-in variables used in the script’s calculations will, in turn, induce changes in the results of those calculations. This is required for the script to follow the realtime price action. As a result, the same script may produce different results every time it executes during the realtime bar. 
Note: In the realtime bar, the close variable always represents the current price. Similarly, the high and low built-in variables represent the highest high and lowest low reached since the realtime bar’s beginning. Pine Script™’s built-in variables will only represent the realtime bar’s final values on the bar’s last update. 
Let’s follow our script example in the realtime bar. 
When the script arrives on the realtime bar it executes a first time. It uses the current values of the built-in variables to produce a set of results and plots them if required. Before the script executes another time when the next update happens, its user-defined variables are reset to a known state corresponding to that of the last commit at the close of the previous bar. If no commit was made on the variables because they are initialized every bar, then they are reinitialized. In both cases their last calculated state is lost. The state of plotted labels and lines is also reset. This resetting of the script’s user-defined variables and drawings prior to each new iteration of the script in the realtime bar is called rollback. Its effect is to reset the script to the same known state it was in when the realtime bar opened, so calculations in the realtime bar are always performed from a clean state. 
The constant recalculation of a script’s values as price or volume changes in the realtime bar can lead to a situation where variable c in our example becomes true because a cross has occurred, and so the red marker plotted by the script’s last line would appear on the chart. If on the next price update the price has moved in such a way that the close value no 
3.1. Execution model 17
Pine Script™ v5 User Manual 
longer produces calculations making c true because there is no longer a cross, then the marker previously plotted will disappear. 
When the realtime bar closes, the script executes a last time. As usual, variables are rolled back prior to execution. However, since this iteration is the last one on the realtime bar, variables are committed to their final values for the bar when calculations are completed. 
To summarize the realtime bar process: 
• A script executes at the open of the realtime bar and then once per update. 
• Variables are rolled back before every realtime update. 
• Variables are committed once at the closing bar update. 
3.1.3 Events triggering the execution of a script 
A script is executed on the complete set of bars on the chart when one of the following events occurs: • A new symbol or timeframe is loaded on a chart. 
• A script is saved or added to the chart, from the Pine Script™ Editor or the chart’s “Indicators & strategies” dialog box. 
• A value is modified in the script’s “Settings/Inputs” dialog box. 
• A value is modified in a strategy’s “Settings/Properties” dialog box. 
• A browser refresh event is detected. 
A script is executed on the realtime bar when trading is active and: 
• One of the above conditions occurs, causing the script to execute on the open of the realtime bar, or • The realtime bar updates because a price or volume change was detected. 
Note that when a chart is left untouched when the market is active, a succession of realtime bars which have been opened and then closed will trail the current realtime bar. While these elapsed realtime bars will have been confirmed because their variables have all been committed, the script will not yet have executed on them in their historical state, since they did not exist when the script was last run on the chart’s dataset. 
When an event triggers the execution of the script on the chart and causes it to run on those bars which have now become historical bars, the script’s calculation can sometimes vary from what they were when calculated on the last closing update of the same bars when they were realtime bars. This can be caused by slight variations between the OHLCV values saved at the close of realtime bars and those fetched from data feeds when the same bars have become historical bars. This behavior is one of the possible causes of repainting. 
3.1.4 More information 
• The built-in barstate.* variables provide information on the type of bar or the event where the script is execut ing. The page where they are documented also contains a script that allows you to visualize the difference between elapsed realtime and historical bars, for example. 
• The Strategies page explains the details of strategy calculations, which are not identical to those of indicators. 18 Chapter 3. Language
Pine Script™ v5 User Manual 
3.1.5 Historical values of functions 
Every function call in Pine leaves a trail of historical values that a script can access on subsequent bars using the [] operator. The historical series of functions depend on successive calls to record the output on every bar. When a script does not call functions on each bar, it can produce an inconsistent history that may impact calculations and results, namely when it depends on the continuity of their historical series to operate as expected. The compiler warns users in these cases to make them aware that the values from a function, whether built-in or user-defined, might be misleading. 
To demonstrate, let’s write a script that calculates the index of the current bar and outputs that value on every second bar. In the following script, we’ve defined a calcBarIndex() function that adds 1 to the previous value of its internal index variable on every bar. The script calls the function on each bar that the condition returns true on (every other bar) to update the customIndex value. It plots this value alongside the built-in bar_index to validate the output: 

1 //@version=5 
2 indicator("My script") 
3 
4 //@function Calculates the index of the current bar by adding 1 to its own value from␣ →the previous bar. 
5 // The first bar will have an index of 0. 
6 calcBarIndex() => 
7 int index = na 
8 index := nz(index[1], replacement = -1) + 1 
9 
10 //@variable Returns `true` on every other bar. 
11 condition = bar_index % 2 == 0 
12 
13 int customIndex = na 
14 
15 // Call `calcBarIndex()` when the `condition` is `true`. This prompts the compiler to␣ →raise a warning. 
16 if condition 
17 customIndex := calcBarIndex() 
18 
19 plot(bar_index, "Bar index", color = color.green) 
20 plot(customIndex, "Custom index", color = color.red, style = plot.style_cross) 3.1. Execution model 19
Pine Script™ v5 User Manual 
Note that: 
• The nz() function replaces na values with a specified replacement value (0 by default). On the first bar of the script, when the index series has no history, the na value is replaced with -1 before adding 1 to return an initial value of 0. 
Upon inspecting the chart, we see that the two plots differ wildly. The reason for this behavior is that the script called calcBarIndex() within the scope of an if structure on every other bar, resulting in a historical output inconsis tent with the bar_index series. When calling the function once every two bars, internally referencing the previous value of index gets the value from two bars ago, i.e., the last bar the function executed on. This behavior results in a customIndex value of half that of the built-in bar_index. 
To align the calcBarIndex() output with the bar_index, we can move the function call to the script’s global scope. That way, the function will execute on every bar, allowing its entire history to be recorded and referenced rather than only the results from every other bar. In the code below, we’ve defined a globalScopeBarIndex variable in the global scope and assigned it to the return from calcBarIndex() rather than calling the function locally. The script sets the customIndex to the value of globalScopeBarIndex on the occurrence of the condition: 

1 //@version=5 
2 indicator("My script") 
3 
4 //@function Calculates the index of the current bar by adding 1 to its own value from␣ →the previous bar. 
5 // The first bar will have an index of 0. 
6 calcBarIndex() => 
7 int index = na 
8 index := nz(index[1], replacement = -1) + 1 
9 
10 //@variable Returns `true` on every second bar. 
11 condition = bar_index % 2 == 0 
12 
13 globalScopeBarIndex = calcBarIndex() 
14 int customIndex = na 
15 
16 // Assign `customIndex` to `globalScopeBarIndex` when the `condition` is `true`. This␣ →won't produce a warning. 
17 if condition 
(continues on next page) 
20 Chapter 3. Language
Pine Script™ v5 User Manual 
(continued from previous page) 
18 customIndex := globalScopeBarIndex 
19 
20 plot(bar_index, "Bar index", color = color.green) 
21 plot(customIndex, "Custom index", color = color.red, style = plot.style_cross) 
This behavior can also radically impact built-in functions that reference history internally. For example, the ta.sma() function references its past values “under the hood”. If a script calls this function conditionally rather than on every bar, the values within the calculation can change significantly. We can ensure calculation consistency by assigning ta.sma() to a variable in the global scope and referencing that variable’s history as needed. 
The following example calculates three SMA series: controlSMA, localSMA, and globalSMA. The script calcu lates controlSMA in the global scope and localSMA within the local scope of an if structure. Within the if structure, it also updates the value of globalSMA using the controlSMA value. As we can see, the values from the glob alSMA and controlSMA series align, whereas the localSMA series diverges from the other two because it uses an incomplete history, which affects its calculations: 

1 //@version=5 
2 indicator("My script") 
3 
4 //@variable Returns `true` on every second bar. 
5 condition = bar_index % 2 == 0 
6 
7 controlSMA = ta.sma(close, 20) 
8 float globalSMA = na 
9 float localSMA = na 
10 
11 // Update `globalSMA` and `localSMA` when `condition` is `true`. 
12 if condition 
13 globalSMA := controlSMA // No warning. 
14 localSMA := ta.sma(close, 20) // Raises warning. This function depends on its␣ →history to work as intended. 
15 
16 plot(controlSMA, "Control SMA", color = color.green) 
17 plot(globalSMA, "Global SMA", color = color.blue, style = plot.style_cross) 18 plot(localSMA, "Local SMA", color = color.red, style = plot.style_cross) 
3.1. Execution model 21
Pine Script™ v5 User Manual 
Why this behavior? 
This behavior is required because forcing the execution of functions on each bar would lead to unexpected results in those functions that produce side effects, i.e., the ones that do something aside from returning the value. For example, the label.new() function creates a label on the chart, so forcing it to be called on every bar even when it is inside of an if structure would create labels where they should not logically appear. 
Exceptions 
Not all built-in functions use their previous values in their calculations, meaning not all require execution on every bar. For example, math.max() compares all arguments passed into it to return the highest value. Such functions that do not interact with their history in any way do not require special treatment. 
If the usage of a function within a conditional block does not cause a compiler warning, it’s safe to use without impacting calculations. Otherwise, move the function call to the global scope to force consistent execution. When keeping a function call within a conditional block despite the warning, ensure the output is correct at the very least to avoid unexpected results. 


3.2 Time series 
Much of the power of Pine Script™ stems from the fact that it is designed to process time series efficiently. Time series are not a qualified type; they are the fundamental structure Pine Script™ uses to store the successive values of a variable over time, where each value is tethered to a point in time. Since charts are composed of bars, each representing a particular point in time, time series are the ideal data structure to work with values that may change with time. 
The notion of time series is intimately linked to Pine Script™’s execution model and type system concepts. Understanding all three is key to making the most of the power of Pine Script™. 
Take the built-in open variable, which contains the “open” price of each bar in the dataset, the dataset being all the bars on any given chart. If your script is running on a 5min chart, then each value in the open time series is the “open” price of the consecutive 5min chart bars. When your script refers to open, it is referring to the “open” price of the bar the script is executing on. To refer to past values in a time series, we use the [] history-referencing operator. When a script is executing on a given bar, open[1] refers to the value of the open time series on the previous bar. 
While time series may remind programmers of arrays, they are totally different. Pine Script™ does use an array data structure, but it is a completely different concept than a time series. 
Time series in Pine Script™, combined with its special type of runtime engine and built-in functions, are what makes it easy to compute the cumulative total of close values without using a for loop, with only ta.cum(close). This is possible because although ta.cum(close) appears rather static in a script, it is in fact executed on each bar, so its value becomes increasingly larger as the close value of each new bar is added to it. When the script reaches the rightmost bar of the chart, ta.cum(close) returns the sum of the close value from all bars on the chart. 
Similarly, the mean of the difference between the last 14 high and low values can be expressed as ta.sma(high - low, 14), or the distance in bars since the last time the chart made five consecutive higher highs as barssince(rising(high, 5)). 
22 Chapter 3. Language
Pine Script™ v5 User Manual 
Even the result of function calls on successive bars leaves a trace of values in a time series that can be referenced using the [] history-referencing operator. This can be useful, for example, when testing the close of the current bar for a breach of the highest high in the last 10 bars, but excluding the current bar, which we could write as breach = close > highest(close, 10)[1]. The same statement could also be written as breach = close > highest(close[1], 10). 
The same looping logic on all bars is applied to function calls such as plot(open) which will repeat on each bar, successively plotting on the chart the value of open for each bar. 
Do not confuse “time series” with the “series” qualifier. The time series concept explains how consecutive values of variables are stored in Pine Script™; the “series” qualifier denotes variables whose values can change bar to bar. Consider, for example, the timeframe.period built-in variable which has the “simple” qualifier and “string” type, meaning it is of the “simple string” qualified type. The “simple” qualifier entails that the variable’s value is established on bar zero (the first bar where the script executes) and will not change during the script’s execution on any of the chart’s bars. The variable’s value is the chart’s timeframe in string format, so "D" for a 1D chart, for example. Even though its value cannot change during the script, it would be syntactically correct in Pine Script™ (though not very useful) to refer to its value 10 bars ago using timeframe.period[10]. This is possible because the successive values of timeframe.period for each bar are stored in a time series, even though all the values in that particular time series are the same. Note, however, that when the [] operator is used to access past values of a variable, it yields a “series” qualified value, even when the variable without an offset uses a different qualifier, such as “simple” in the case of timeframe.period. 
When you grasp how time series can be efficiently handled using Pine Script™’s syntax and its execution model, you can define complex calculations using little code. 


3.3 Script structure 
• Version 
• Declaration statement 
• Code 
• Comments 
• Line wrapping 
• Compiler annotations
	



A Pine script follows this general structure: 
<version> 
<declaration_statement> 
<code> 
3.3. Script structure 23
Pine Script™ v5 User Manual 
3.3.1 Version 
A compiler annotation in the following form tells the compiler which of the versions of Pine Script™ the script is written in: 
1 //@version=5 
• The version number can be 1 to 5. 
• The compiler annotation is not mandatory. When omitted, version 1 is assumed. It is strongly recommended to always use the latest version of the language. 
• While it is synctactically correct to place the version compiler annotation anywhere in the script, it is much more useful to readers when it appears at the top of the script. 
Notable changes to the current version of Pine Script™ are documented in the Release notes. 
3.3.2 Declaration statement 
All Pine scripts must contain one declaration statement, which is a call to one of these functions: • indicator() 
• strategy() 
• library() 
The declaration statement: 
• Identifies the type of the script, which in turn dictates which content is allowed in it, and how it can be used and executed. 
• Sets key properties of the script such as its name, where it will appear when it is added to a chart, the precision and format of the values it displays, and certain values that govern its runtime behavior, such as the maximum number of drawing objects it will display on the chart. With strategies, the properties include parameters that control backtesting, such as initial capital, commission, slippage, etc. 
Each type of script has distinct requirements: 
• Indicators must contain at least one function call which produces output on the chart (e.g., plot(), plotshape(), barcolor(), line.new(), etc.). 
• Strategies must contain at least one strategy.*() call, e.g., strategy.entry(). 
• Libraries must contain at least one exported function or user-defined type. 
3.3.3 Code 
Lines in a script that are not comments or compiler annotations are statements, which implement the script’s algorithm. A statement can be one of these: 
• variable declaration 
• variable reassignement 
• function declaration 
• built-in function call, user-defined function call or a library function call 
• if, for, while, switch or type structure. 
Statements can be arranged in multiple ways: 
24 Chapter 3. Language
Pine Script™ v5 User Manual 
• Some statements can be expressed in one line, like most variable declarations, lines containing only a function call or single-line function declarations. Lines can also be wrapped (continued on multiple lines). Multiple one-line statements can be concatenated on a single line by using the comma as a separator. 
• Others statements such as structures or multi-line function declarations always require multiple lines because they require a local block. A local block must be indented by a tab or four spaces. Each local block defines a distinct local scope. 
• Statements in the global scope of the script (i.e., which are not part of local blocks) cannot begin with white space (a space or a tab). Their first character must also be the line’s first character. Lines beginning in a line’s first position become by definition part of the script’s global scope. 
A simple valid Pine Script™ v5 indicator can be generated in the Pine Script™ Editor by using the “Open” button and choosing “New blank indicator”: 
1 //@version=5 
2 indicator("My Script") 
3 plot(close) 
This indicator includes three local blocks, one in the f() function declaration, and two in the variable declaration using an if structure: 
1 //@version=5 
2 
3 indicator("", "", true) // Declaration statement (global scope) 
4 
5 barIsUp() => // Function declaration (global scope) 
6 close > open // Local block (local scope) 
7 
8 plotColor = if barIsUp() // Variable declaration (global scope) 
9 color.green // Local block (local scope) 
10 else 
11 color.red // Local block (local scope) 
12 
13 bgcolor(color.new(plotColor, 70)) // Call to a built-in function (global scope) 
You can bring up a simple Pine Script™ v5 strategy by selecting “New blank strategy” instead: 
1 //@version=5 
2 strategy("My Strategy", overlay=true, margin_long=100, margin_short=100) 
3 
4 longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28)) 5 if (longCondition) 
6 strategy.entry("My Long Entry Id", strategy.long) 
7 
8 shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28)) 9 if (shortCondition) 
10 strategy.entry("My Short Entry Id", strategy.short) 
3.3. Script structure 25
Pine Script™ v5 User Manual 
3.3.4 Comments 
Double slashes (//) define comments in Pine Script™. Comments can begin anywhere on the line. They can also follow Pine Script™ code on the same line: 
1 //@version=5 
2 indicator("") 
3 // This line is a comment 
4 a = close // This is also a comment 
5 plot(a) 
The Pine Editor has a keyboard shortcut to comment/uncomment lines: ctrl + /. You can use it on multiple lines by highlighting them first. 
3.3.5 Line wrapping 
Long lines can be split on multiple lines, or “wrapped”. Wrapped lines must be indented with any number of spaces, provided it’s not a multiple of four (those boundaries are used to indent local blocks): 
a = open + high + low + close 
may be wrapped as: 
a = open + 
high + 
low + 
close 
A long plot() call may be wrapped as: 
plot(ta.correlation(src, ovr, length), 
color = color.new(color.purple, 40), 
style = plot.style_area, 
trackprice = true) 
Statements inside user-defined function declarations can also be wrapped. However, since a local block must syntactically begin with an indentation (4 spaces or 1 tab), when splitting it onto the following line, the continuation of the statement must start with more than one indentation (not equal to a multiple of four spaces). For example: 
updown(s) => 
isEqual = s == s[1] 
isGrowing = s > s[1] 
ud = isEqual ? 
0 : 
isGrowing ? 
(nz(ud[1]) <= 0 ? 
1 : 
nz(ud[1])+1) : 
(nz(ud[1]) >= 0 ? 
-1 : 
nz(ud[1])-1) 
You can use comments in wrapped lines: 
26 Chapter 3. Language
Pine Script™ v5 User Manual 
1 //@version=5 
2 indicator("") 
3 c = open > close ? color.red : 
4 high > high[1] ? color.lime : // A comment 
5 low < low[1] ? color.blue : color.black 
6 bgcolor(c) 
3.3.6 Compiler annotations 
Compiler annotations are comments that issue special instructions for a script: 
• //@version= specifies the PineScript™ version that the compiler will use. The number in this annotation should not be confused with the script’s revision number, which updates on every saved change to the code. 
• //@description sets a custom description for scripts that use the library() declaration statement. 
• //@function, //@param and //@returns add custom descriptions for a user-defined function, its param eters, and its result when placed above the function declaration. 
• //@type and //@field add custom descriptions for a user-defined type (UDT) and its fields when placed above the type declaration. 
• //@variable adds a custom description for a variable when placed above its declaration. 
• //@strategy_alert_message provides a default message for strategy scripts to pre-fill the “Message” field in the alert creation dialogue. 
• //#region and //#endregion create collapsible code regions in the Pine Editor. Clicking the dropdown arrow next to //#region collapses the lines of code between the two annotations. 
This script draws a rectangle using three interactively selected points on the chart. It illustrates how compiler annotations can be used: 

1 //@version=5 
2 indicator("Triangle", "", true) 
3 
4 int TIME_DEFAULT = 0 
5 float PRICE_DEFAULT = 0.0 
6 
(continues on next page) 
3.3. Script structure 27
Pine Script™ v5 User Manual 
(continued from previous page) 
7 x1Input = input.time(TIME_DEFAULT, "Point 1", inline = "1", confirm = true) 8 y1Input = input.price(PRICE_DEFAULT, "", inline = "1", tooltip = "Pick point 1 →", confirm = true) 
9 x2Input = input.time(TIME_DEFAULT, "Point 2", inline = "2", confirm = true) 10 y2Input = input.price(PRICE_DEFAULT, "", inline = "2", tooltip = "Pick point 2 →", confirm = true) 
11 x3Input = input.time(TIME_DEFAULT, "Point 3", inline = "3", confirm = true) 12 y3Input = input.price(PRICE_DEFAULT, "", inline = "3", tooltip = "Pick point 3 →", confirm = true) 
13 
14 // @type Used to represent the coordinates and color to draw a triangle. 15 // @field time1 Time of first point. 
16 // @field time2 Time of second point. 
17 // @field time3 Time of third point. 
18 // @field price1 Price of first point. 
19 // @field price2 Price of second point. 
20 // @field price3 Price of third point. 
21 // @field lineColor Color to be used to draw the triangle lines. 
22 type Triangle 
23 int time1 
24 int time2 
25 int time3 
26 float price1 
27 float price2 
28 float price3 
29 color lineColor 
30 
31 //@function Draws a triangle using the coordinates of the `t` object. 32 //@param t (Triangle) Object representing the triangle to be drawn. 33 //@returns The ID of the last line drawn. 
34 drawTriangle(Triangle t) => 
35 line.new(t.time1, t.price1, t.time2, t.price2, xloc = xloc.bar_time, color = t. →lineColor) 
36 line.new(t.time2, t.price2, t.time3, t.price3, xloc = xloc.bar_time, color = t. →lineColor) 
37 line.new(t.time1, t.price1, t.time3, t.price3, xloc = xloc.bar_time, color = t. →lineColor) 
38 
39 // Draw the triangle only once on the last historical bar. 
40 if barstate.islastconfirmedhistory 
41 //@variable Used to hold the Triangle object to be drawn. 
42 Triangle triangle = Triangle.new() 
43 
44 triangle.time1 := x1Input 
45 triangle.time2 := x2Input 
46 triangle.time3 := x3Input 
47 triangle.price1 := y1Input 
48 triangle.price2 := y2Input 
49 triangle.price3 := y3Input 
50 triangle.lineColor := color.purple 
51 
52 drawTriangle(triangle) 

28 Chapter 3. Language
Pine Script™ v5 User Manual 

3.4 Identifiers 
Identifiers are names used for user-defined variables and functions: 
• They must begin with an uppercase (A-Z) or lowercase (a-z) letter, or an underscore (_). • The next characters can be letters, underscores or digits (0-9). 
• They are case-sensitive. 
Here are some examples: 
myVar 
_myVar 
my123Var 
functionName 
MAX_LEN 
max_len 
maxLen 
3barsDown // NOT VALID! 
The Pine Script™ Style Guide recommends using uppercase SNAKE_CASE for constants, and camelCase for other identifiers: 
GREEN_COLOR = #4CAF50 
MAX_LOOKBACK = 100 
int fastLength = 7 
// Returns 1 if the argument is `true`, 0 if it is `false` or `na`. zeroOne(boolValue) => boolValue ? 1 : 0 


3.4. Identifiers 29
Pine Script™ v5 User Manual 
3.5 Operators 
• Introduction 
• Arithmetic operators 
• Comparison operators 
• Logical operators 
• `?:` ternary operator 
• `[ ]` history-referencing operator 
• Operator precedence 
• `=` assignement operator 
• `:=` reassignement operator
	



3.5.1 Introduction 
Some operators are used to build expressions returning a result: 
• Arithmetic operators 
• Comparison operators 
• Logical operators 
• The ?: ternary operator 
• The [] history-referencing operator 
Other operators are used to assign values to variables: 
• = is used to assign a value to a variable, but only when you declare the variable (the first time you use it) 
• := is used to assign a value to a previously declared variable. The following operators can also be used in such a way: +=, -=, *=, /=, %= 
As is explained in the Type system page, qualifiers and types play a critical role in determining the type of results that expressions yield. This, in turn, has an impact on how and with what functions you will be allowed to use those results. Expressions always return a value with the strongest qualifier used in the expression, e.g., if you multiply an “input int” with a “series int”, the expression will produce a “series int” result, which you will not be able to use as the argument to length in ta.ema(). 
This script will produce a compilation error: 
1 //@version=5 
2 indicator("") 
3 lenInput = input.int(14, "Length") 
4 factor = year > 2020 ? 3 : 1 
5 adjustedLength = lenInput * factor 
6 ma = ta.ema(close, adjustedLength) // Compilation error! 
7 plot(ma) 
The compiler will complain: Cannot call ‘ta.ema’ with argument ‘length’=’adjustedLength’. An argument of ‘series int’ type was used but a ‘simple int’ is expected;. This is happening because lenInput is an “input int” but factor is a “series int” (it can only be determined by looking at the value of year on each bar). The adjustedLength variable is 
30 Chapter 3. Language
Pine Script™ v5 User Manual 
thus assigned a “series int” value. Our problem is that the Reference Manual entry for ta.ema() tells us that its length parameter requires a “simple” value, which is a weaker qualifier than “series”, so a “series int” value is not allowed. 
The solution to our conundrum requires: 
• Using another moving average function that supports a “series int” length, such as ta.sma(), or • Not using a calculation producing a “series int” value for our length. 
3.5.2 Arithmetic operators 
There are five arithmetic operators in Pine Script™: 
+ Addition and string concatenation 
- Subtraction 
* Multiplication 
/ Division 
% Modulo (remainder after division) 
The arithmetic operators above are all binary (means they need two operands — or values — to work on, like in 1 + 2). The + and - also serve as unary operators (means they work on one operand, like -1 or +1). 
If both operands are numbers but at least one of these is of float type, the result will also be a float. If both operands are of int type, the result will also be an int. If at least one operand is na, the result is also na. 
The + operator also serves as the concatenation operator for strings. "EUR"+"USD" yields the "EURUSD" string. 
The % operator calculates the modulo by rounding down the quotient to the lowest possible value. Here is an easy example that helps illustrate how the modulo is calculated behind the scenes: 
3.5.3 Comparison operators 
There are six comparison operators in Pine Script™: 
< Less Than 
<= Less Than or Equal To 
!= Not Equal 
== Equal 
> Greater Than 
>= Greater Than or Equal To 
Comparison operations are binary. If both operands have a numerical value, the result will be of type bool, i.e., true, false or na. 
Examples: 
1 > 2 // false 
1 != 1 // false 
close >= open // Depends on values of `close` and `open` 
3.5. Operators 31
Pine Script™ v5 User Manual 
3.5.4 Logical operators 
There are three logical operators in Pine Script™: 
not Negation 
and Logical Conjunction 
or Logical Disjunction 
The operator not is unary. When applied to a true, operand the result will be false, and vice versa. and operator truth table: 
a b a and b 
true true true 
true false false 
false true false 
false false false 
or operator truth table: 
a b a or b 
true true true 
true false true 
false true true 
false false false 
3.5.5 `?:` ternary operator 
The ?: ternary operator is used to create expressions of the form: 
condition ? valueWhenConditionIsTrue : valueWhenConditionIsFalse 
The ternary operator returns a result that depends on the value of condition. If it is true, then valueWhenCon ditionIsTrue is returned. If condition is false or na, then valueWhenConditionIsFalse is returned. 
A combination of ternary expressions can be used to achieve the same effect as a switch structure, e.g.: 
timeframe.isintraday ? color.red : timeframe.isdaily ? color.green : timeframe. →ismonthly ? color.blue : na 
The example is calculated from left to right: 
• Iftimeframe.isintraday is true, then color.red is returned. If it is false, then timeframe.isdaily is evaluated. 
• If timeframe.isdaily is true, then color.green is returned. If it is false, then timeframe.ismonthly is evaluated. 
• If timeframe.ismonthly is true, then color.blue is returned, otherwise na is returned. 
Note that the return values on each side of the : are expressions — not local blocks, so they will not affect the limit of 500 local blocks per scope. 
32 Chapter 3. Language
Pine Script™ v5 User Manual 
3.5.6 `[ ]` history-referencing operator 
It is possible to refer to past values of time series using the [] history-referencing operator. Past values are values a variable had on bars preceding the bar where the script is currently executing — the current bar. See the Execution model page for more information about the way scripts are executed on bars. 
The [] operator is used after a variable, expression or function call. The value used inside the square brackets of the operator is the offset in the past we want to refer to. To refer to the value of the volume built-in variable two bars away from the current bar, one would use volume[2]. 
Because series grow dynamically, as the script moves on sucessive bars, the offset used with the operator will refer to different bars. Let’s see how the value returned by the same offset is dynamic, and why series are very different from arrays. In Pine Script™, the close variable, or close[0] which is equivalent, holds the value of the current bar’s “close”. If your code is now executing on the third bar of the dataset (the set of all bars on your chart), close will contain the price at the close of that bar, close[1] will contain the price at the close of the preceding bar (the dataset’s second bar), and close[2], the first bar. close[3] will return na because no bar exists in that position, and thus its value is not available. 
When the same code is executed on the next bar, the fourth in the dataset, close will now contain the closing price of that bar, and the same close[1] used in your code will now refer to the “close” of the third bar in the dataset. The close of the first bar in the dataset will now be close[3], and this time close[4] will return na. 
In the Pine Script™ runtime environment, as your code is executed once for each historical bar in the dataset, starting from the left of the chart, Pine Script™ is adding a new element in the series at index 0 and pushing the pre-existing elements in the series one index further away. Arrays, in comparison, can have constant or variable sizes, and their content or indexing structure is not modified by the runtime environment. Pine Script™ series are thus very different from arrays and only share familiarity with them through their indexing syntax. 
When the market for the chart’s symbol is open and the script is executing on the chart’s last bar, the realtime bar, close returns the value of the current price. It will only contain the actual closing price of the realtime bar the last time the script is executed on that bar, when it closes. 
Pine Script™ has a variable that contains the number of the bar the script is executing on: bar_index. On the first bar, bar_index is equal to 0 and it increases by 1 on each successive bar the script executes on. On the last bar, bar_index is equal to the number of bars in the dataset minus one. 
There is another important consideration to keep in mind when using the [] operator in Pine Script™. We have seen cases when a history reference may return the na value. na represents a value which is not a number and using it in any expression will produce a result that is also na (similar to NaN). Such cases often happen during the script’s calculations in the early bars of the dataset, but can also occur in later bars under certain conditions. If your code does not explicitly provide for handling these special cases, they can introduce invalid results in your script’s calculations which can ripple through all the way to the realtime bar. The na and nz functions are designed to allow for handling such cases. 
These are all valid uses of the [] operator: 
high[10] 
ta.sma(close, 10)[1] 
ta.highest(high, 10)[20] 
close > nz(close[1], open) 
Note that the [] operator can only be used once on the same value. This is not allowed: 
close[1][2] // Error: incorrect use of [] operator 
3.5. Operators 33
Pine Script™ v5 User Manual 
3.5.7 Operator precedence 
The order of calculations is determined by the operators’ precedence. Operators with greater precedence are calculated first. Below is a list of operators sorted by decreasing precedence: 
Precedence Operator 
9 [] 
8 unary +, unary -, not 
7 *, /, % 
6 +, - 
5 >, <, >=, <= 
4 ==, != 
3 and 
2 or 
1 ?: 
If in one expression there are several operators with the same precedence, then they are calculated left to right. 
If the expression must be calculated in a different order than precedence would dictate, then parts of the expression can be grouped together with parentheses. 
3.5.8 `=` assignement operator 
The = operator is used to assign a variable when it is initialized — or declared —, i.e., the first time you use it. It says this is a new variable that I will be using, and I want it to start on each bar with this value. 
These are all valid variable declarations: 
i = 1 
MS_IN_ONE_MINUTE = 1000 * 60 
showPlotInput = input.bool(true, "Show plots") 
pHi = pivothigh(5, 5) 
plotColor = color.green 
See the Variable declarations page for more information on how to declare variables. 
3.5.9 `:=` reassignement operator 
The := is used to reassign a value to an existing variable. It says use this variable that was declared earlier in my script, and give it a new value. 
Variables which have been first declared, then reassigned using :=, are called mutable variables. All the following ex amples are valid variable reassignments. You will find more information on how var works in the section on the `var` declaration mode: 
1 //@version=5 
2 indicator("", "", true) 
3 // Declare `pHi` and initilize it on the first bar only. 
4 var float pHi = na 
5 // Reassign a value to `pHi` 
6 pHi := nz(ta.pivothigh(5, 5), pHi) 
7 plot(pHi) 
Note that: 
34 Chapter 3. Language
Pine Script™ v5 User Manual 
• We declare pHi with this code: var float pHi = na. The var keyword tells Pine Script™ that we only want that variable initialized with na on the dataset’s first bar. The float keyword tells the compiler we are declaring a variable of type “float”. This is necessary because, contrary to most cases, the compiler cannot automatically determine the type of the value on the right side of the = sign. 
• While the variable declaration will only be executed on the first bar because it uses var, the pHi := nz(ta. pivothigh(5, 5), pHi) line will be executed on all the chart’s bars. On each bar, it evaluates if the pivothigh() call returns na because that is what the function does when it hasn’t found a new pivot. The nz() function is the one doing the “checking for na” part. When its first argument (ta.pivothigh(5, 5)) is na, it returns the second argument (pHi) instead of the first. When pivothigh() returns the price point of a newly found pivot, that value is assigned to pHi. When it returns na because no new pivot was found, we assign the previous value of pHi to itself, in effect preserving its previous value. 
The output of our script looks like this: 
Note that: 
• The line preserves its previous value until a new pivot is found. 
• Pivots are detected five bars after the pivot actually occurs because our ta.pivothigh(5, 5) call says that we require five lower highs on both sides of a high point for it to be detected as a pivot. 
See the Variable reassignment section for more information on how to reassign values to variables. 

3.5. Operators 35
Pine Script™ v5 User Manual 
3.6 Variable declarations 
• Introduction 
• Variable reassignment 
• Declaration modes
	



3.6.1 Introduction 
Variables are identifiers that hold values. They must be declared in your code before you use them. The syntax of variable declarations is: 
[<declaration_mode>] [<type>] <identifier> = <expression> | <structure> 
or 
<tuple_declaration> = <function_call> | <structure> 
where: 
• | means “or”, and parts enclosed in square brackets ([]) can appear zero or one time. 
• <declaration_mode> is the variable’s declaration mode. It can be var or varip, or nothing. • <type> is optional, as in almost all Pine Script™ variable declarations (see types). 
• <identifier> is the variable’s name. 
• <expression> can be a literal, a variable, an expression or a function call. 
• <structure> can be an if, for, while or switch structure. 
• <tuple_declaration> is a comma-separated list of variable names enclosed in square brackets ([]), e.g., [ma, upperBand, lowerBand]. 
These are all valid variable declarations. The last one requires four lines: 
BULL_COLOR = color.lime 
i = 1 
len = input(20, "Length") 
float f = 10.5 
closeRoundedToTick = math.round_to_mintick(close) 
st = ta.supertrend(4, 14) 
var barRange = float(na) 
var firstBarOpen = open 
varip float lastClose = na 
[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9) 
plotColor = if close > open 
color.green 
else 
color.red 
Note: The above statements all contain the = assignment operator because they are variable declarations. When you see similar lines using the := reassignment operator, the code is reassigning a value to a variable that was already 
36 Chapter 3. Language
Pine Script™ v5 User Manual 
declared. Those are variable reassignments. Be sure you understand the distinction as this is a common stumbling block for newcomers to Pine Script™. See the next Variable reassignment section for details. 
The formal syntax of a variable declaration is: 
<variable_declaration> 
[<declaration_mode>] [<type>] <identifier> = <expression> | <structure> | 
<tuple_declaration> = <function_call> | <structure> 
<declaration_mode> 
var | varip 
<type> 
int | float | bool | color | string | line | linefill | label | box | table |␣ →array<type> | matrix<type> | UDF 
Initialization with `na` 
In most cases, an explicit type declaration is redundant because type is automatically inferred from the value on the right of the = at compile time, so the decision to use them is often a matter of preference. For example: 
baseLine0 = na // compile time error! 
float baseLine1 = na // OK 
baseLine2 = float(na) // OK 
In the first line of the example, the compiler cannot determine the type of the baseLine0 variable because na is a generic value of no particular type. The declaration of the baseLine1 variable is correct because its float type is declared explicitly. The declaration of the baseLine2 variable is also correct because its type can be derived from the expression float(na), which is an explicit cast of the na value to the float type. The declarations of baseLine1 and baseLine2 are equivalent. 
Tuple declarations 
Function calls or structures are allowed to return multiple values. When we call them and want to store the values they return, a tuple declaration must be used, which is a comma-separated set of one or more values enclosed in brackets. This allows us to declare multiple variables simultaneously. As an example, the ta.bb() built-in function for Bollinger bands returns three values: 
[bbMiddle, bbUpper, bbLower] = ta.bb(close, 5, 4) 
3.6.2 Variable reassignment 
A variable reassignment is done using the := reassignment operator. It can only be done after a variable has been first declared and given an initial value. Reassigning a new value to a variable is often necessary in calculations, and it is always necessary when a variable from the global scope must be assigned a new value from within a structure’s local block, e.g.: 
1 //@version=5 
2 indicator("", "", true) 
3 sensitivityInput = input.int(2, "Sensitivity", minval = 1, tooltip = "Higher values␣ →make color changes less sensitive.") 
4 ma = ta.sma(close, 20) 
(continues on next page) 
3.6. Variable declarations 37
Pine Script™ v5 User Manual 
(continued from previous page) 
5 maUp = ta.rising(ma, sensitivityInput) 
6 maDn = ta.falling(ma, sensitivityInput) 
7 
8 // On first bar only, initialize color to gray 
9 var maColor = color.gray 
10 if maUp 
11 // MA has risen for two bars in a row; make it lime. 
12 maColor := color.lime 
13 else if maDn 
14 // MA has fallen for two bars in a row; make it fuchsia. 
15 maColor := color.fuchsia 
16 
17 plot(ma, "MA", maColor, 2) 
Note that: 
• We initialize maColor on the first bar only, so it preserves its value across bars. 
• On every bar, the if statement checks if the MA has been rising or falling for the user-specified number of bars (the default is 2). When that happens, the value of maColor must be reassigned a new value from within the if local blocks. To do this, we use the := reassignment operator. 
• If we did not use the := reassignment operator, the effect would be to initialize a new maColor local variable which would have the same name as that of the global scope, but actually be a very confusing independent entity that would persist only for the length of the local block, and then disappear without a trace. 
All user-defined variables in Pine Script™ are mutable, which means their value can be changed using the := reassignment operator. Assigning a new value to a variable may change its type qualifier (see the page on Pine Script™’s type system for more information). A variable can be assigned a new value as many times as needed during the script’s execution on one bar, so a script can contain any number of reassignments of one variable. A variable’s declaration mode determines how new values assigned to a variable will be saved. 
3.6.3 Declaration modes 
Understanding the impact that declaration modes have on the behavior of variables requires prior knowledge of Pine Script™’s execution model. 
When you declare a variable, if a declaration mode is specified, it must come first. Three modes can be used: • “On each bar”, when none is specified 
• var 
• varip 
On each bar 
When no explicit declaration mode is specified, i.e. no var or varip keyword is used, the variable is declared and initialized on each bar, e.g., the following declarations from our first set of examples in this page’s introduction: 
BULL_COLOR = color.lime 
i = 1 
len = input(20, "Length") 
float f = 10.5 
closeRoundedToTick = math.round_to_mintick(close) 
st = ta.supertrend(4, 14) 
(continues on next page) 
38 Chapter 3. Language
Pine Script™ v5 User Manual 
(continued from previous page) 
[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9) 
plotColor = if close > open 
color.green 
else 
color.red 
`var` 
When the var keyword is used, the variable is only initialized once, on the first bar if the declaration is in the global scope, or the first time the local block is executed if the declaration is inside a local block. After that, it will preserve its last value on successive bars, until we reassign a new value to it. This behavior is very useful in many cases where a variable’s value must persist through the iterations of a script across successive bars. For example, suppose we’d like to count the number of green bars on the chart: 
1 //@version=5 
2 indicator("Green Bars Count") 
3 var count = 0 
4 isGreen = close >= open 
5 if isGreen 
6 count := count + 1 
7 plot(count) 

Without the var modifier, variable count would be reset to zero (thus losing its value) every time a new bar update triggered a script recalculation. 
Declaring variables on the first bar only is often useful to manage drawings more efficiently. Suppoose we want to extend the last bar’s close line to the right of the right chart. We could write: 
1 //@version=5 
2 indicator("Inefficient version", "", true) 
3 closeLine = line.new(bar_index - 1, close, bar_index, close, extend = extend.right,␣ →width = 3) 
4 line.delete(closeLine[1]) 
3.6. Variable declarations 39
Pine Script™ v5 User Manual 
but this is inefficient because we are creating and deleting the line on each historical bar and on each update in the realtime bar. It is more efficient to use: 
1 //@version=5 
2 indicator("Efficient version", "", true) 
3 var closeLine = line.new(bar_index - 1, close, bar_index, close, extend = extend. →right, width = 3) 
4 if barstate.islast 
5 line.set_xy1(closeLine, bar_index - 1, close) 
6 line.set_xy2(closeLine, bar_index, close) 
Note that: 
• We initialize closeLine on the first bar only, using the var declaration mode 
• We restrict the execution of the rest of our code to the chart’s last bar by enclosing our code that updates the line in an if barstate.islast structure. 
There is a very slight penalty performance for using the var declaration mode. For that reason, when declaring constants, it is preferable not to use var if performance is a concern, unless the initialization involves calculations that take longer than the maintenance penalty, e.g., functions with complex code or string manipulations. 
`varip` 
Understanding the behavior of variables using the varip declaration mode requires prior knowledge of Pine Script™’s execution model and bar states. 
The varip keyword can be used to declare variables that escape the rollback process, which is explained in the page on Pine Script™’s execution model. 
Whereas scripts only execute once at the close of historical bars, when a script is running in realtime, it executes every time the chart’s feed detects a price or volume update. At every realtime update, Pine Script™’s runtime normally resets the values of a script’s variables to their last committed value, i.e., the value they held when the previous bar closed. This is generally handy, as each realtime script execution starts from a known state, which simplifies script logic. 
Sometimes, however, script logic requires code to be able to save variable values between different executions in the realtime bar. Declaring variables with varip makes that possible. The “ip” in varip stands for intrabar persist. 
Let’s look at the following code, which does not use varip: 
1 //@version=5 
2 indicator("") 
3 int updateNo = na 
4 if barstate.isnew 
5 updateNo := 1 
6 else 
7 updateNo := updateNo + 1 
8 
9 plot(updateNo, style = plot.style_circles) 
On historical bars, barstate.isnew is always true, so the plot shows a value of “1” because the else part of the if structure is never executed. On realtime bars, barstate.isnew is only true when the script first executes on the bar’s “open”. The plot will then briefly display “1” until subsequent executions occur. On the next executions during the realtime bar, the second branch of the if statement is executed because barstate.isnew is no longer true. Since updateNo is initialized to na at each execution, the updateNo + 1 expression yields na, so nothing is plotted on further realtime executions of the script. 
If we now use varip to declare the updateNo variable, the script behaves very differently: 
40 Chapter 3. Language
Pine Script™ v5 User Manual 
1 //@version=5 
2 indicator("") 
3 varip int updateNo = na 
4 if barstate.isnew 
5 updateNo := 1 
6 else 
7 updateNo := updateNo + 1 
8 
9 plot(updateNo, style = plot.style_circles) 
The difference now is that updateNo tracks the number of realtime updates that occur on each realtime bar. This can happen because the varip declaration allows the value of updateNo to be preserved between realtime updates; it is no longer rolled back at each realtime execution of the script. The test on barstate.isnew allows us to reset the update count when a new realtime bar comes in. 
Because varip only affects the behavior of your code in the realtime bar, it follows that backtest results on strategies designed using logic based on varip variables will not be able to reproduce that behavior on historical bars, which will invalidate test results on them. This also entails that plots on historical bars will not be able to reproduce the script’s behavior in realtime. 


3.7 Conditional structures 
• Introduction 
• `if` structure 
• `switch` structure 
• Matching local block type requirement
	



3.7.1 Introduction 
The conditional structures in Pine Script™ are if and switch. They can be used: 
• For their side effects, i.e., when they don’t return a value but do things, like reassign values to variables or call functions. 
• To return a value or a tuple which can then be assigned to one (or more, in the case of tuples) variable. 
Conditional structures, like the for and while structures, can be embedded; you can use an if or switch inside another structure. 
Some Pine Script™ built-in functions cannot be called from within the local blocks of conditional structures. They are: alertcondition(), barcolor(), fill(), hline(), indicator(), library(), plot(), plotbar(), plotcandle(), plotchar(), plotshape(), 
3.7. Conditional structures 41
Pine Script™ v5 User Manual 
strategy(). This does not entail their functionality cannot be controlled by conditions evaluated by your script — only that it cannot be done by including them in conditional structures. Note that while input*.() function calls are allowed in local blocks, their functionality is the same as if they were in the script’s global scope. 
The local blocks in conditional structures must be indented by four spaces or a tab. 
3.7.2 `if` structure 
`if` used for its side effects 
An if structure used for its side effects has the following syntax: 
if <expression> 
<local_block> 
{else if <expression> 
<local_block>} 
[else 
<local_block>] 
where: 
• Parts enclosed in square brackets ([]) can appear zero or one time, and those enclosed in curly braces ({}) can appear zero or more times. 
• <expression> must be of “bool” type or be auto-castable to that type, which is only possible for “int” or “float” values (see the Type system page). 
• <local_block> consists of zero or more statements followed by a return value, which can be a tuple of values. It must be indented by four spaces or a tab. 
• There can be zero or more else if clauses. 
• There can be zero or one else clause. 
When the <expression> following the if evaluates to true, the first local block is executed, the if structure’s execution ends, and the value(s) evaluated at the end of the local block are returned. 
When the <expression> following the if evaluates to false, the successive else if clauses are evaluated, if there are any. When the <expression> of one evaluates to true, its local block is executed, the if structure’s execution ends, and the value(s) evaluated at the end of the local block are returned. 
When no <expression> has evaluated to true and an else clause exists, its local block is executed, the if structure’s execution ends, and the value(s) evaluated at the end of the local block are returned. 
When no <expression> has evaluated to true and no else clause exists, na is returned. 
Using if structures for their side effects can be useful to manage the order flow in strategies, for example. While the same functionality can often be achieved using the when parameter in strategy.*() calls, code using if structures is easier to read: 
if (ta.crossover(source, lower)) 
strategy.entry("BBandLE", strategy.long, stop=lower, 
oca_name="BollingerBands", 
oca_type=strategy.oca.cancel, comment="BBandLE") 
else 
strategy.cancel(id="BBandLE") 
Restricting the execution of your code to specific bars ican be done using if structures, as we do here to restrict updates to our label to the chart’s last bar: 
42 Chapter 3. Language
Pine Script™ v5 User Manual 
1 //@version=5 
2 indicator("", "", true) 
3 var ourLabel = label.new(bar_index, na, na, color = color(na), textcolor = color. →orange) 
4 if barstate.islast 
5 label.set_xy(ourLabel, bar_index + 2, hl2[1]) 
6 label.set_text(ourLabel, str.tostring(bar_index + 1, "# bars in chart")) 
Note that: 
• We initialize the ourLabel variable on the script’s first bar only, as we use the var declaration mode. The value used to initialize the variable is provided by the label.new() function call, which returns a label ID pointing to the label it creates. We use that call to set the label’s properties because once set, they will persist until we change them. 
• What happens next is that on each successive bar the Pine Script™ runtime will skip the initialization of ourLa bel, and the if structure’s condition (barstate.islast) is evaluated. It returns false on all bars until the last one, so the script does nothing on most historical bars after bar zero. 
• On the last bar, barstate.islast becomes true and the structure’s local block executes, modifying on each chart update the properties of our label, which displays the number of bars in the dataset. 
• We want to display the label’s text without a background, so we make the label’s background na in the label.new() function call, and we use hl2[1] for the label’s y position because we don’t want it to move all the time. By using the average of the previous bar’s high and low values, the label doesn’t move until the moment when the next realtime bar opens. 
• We use bar_index + 2 in our label.set_xy() call to offset the label to the right by two bars. 
`if` used to return a value 
An if structure used to return one or more values has the following syntax: 
[<declaration_mode>] [<type>] <identifier> = if <expression> 
<local_block> 
{else if <expression> 
<local_block>} 
[else 
<local_block>] 
where: 
• Parts enclosed in square brackets ([]) can appear zero or one time, and those enclosed in curly braces ({}) can appear zero or more times. 
• <declaration_mode> is the variable’s declaration mode 
• <type> is optional, as in almost all Pine Script™ variable declarations (see types) 
• <identifier> is the variable’s name 
• <expression> can be a literal, a variable, an expression or a function call. 
• <local_block> consists of zero or more statements followed by a return value, which can be a tuple of values. It must be indented by four spaces or a tab. 
• The value assigned to the variable is the return value of the <local_block>, or na if no local block is executed. This is an example: 
3.7. Conditional structures 43
Pine Script™ v5 User Manual 
1 //@version=5 
2 indicator("", "", true) 
3 string barState = if barstate.islastconfirmedhistory 
4 "islastconfirmedhistory" 
5 else if barstate.isnew 
6 "isnew" 
7 else if barstate.isrealtime 
8 "isrealtime" 
9 else 
10 "other" 
11 
12 f_print(_text) => 
13 var table _t = table.new(position.middle_right, 1, 1) 
14 table.cell(_t, 0, 0, _text, bgcolor = color.yellow) 
15 f_print(barState) 
It is possible to omit the else block. In this case, if the condition is false, an empty value (na, false, or "") will be assigned to the var_declarationX variable. 
This is an example showing how na is returned when no local block is executed. If close > open is false in here, na is returned: 
x = if close > open 
close 
Scripts can contain if structures with nested if and other conditional structures. For example: 
if condition1 
if condition2 
if condition3 
expression 
However, nesting these structures is not recommended from a performance perspective. When possible, it is typically more optimal to compose a single if statement with multiple logical operators rather than several nested if blocks: 
if condition1 and condition2 and condition3 
expression 
3.7.3 `switch` structure 
The switch structure exists in two forms. One switches on the different values of a key expression: 
[[<declaration_mode>] [<type>] <identifier> = ]switch <expression> 
{<expression> => <local_block>} 
=> <local_block> 
The other form does not use an expression as a key; it switches on the evaluation of different expressions: 
[[<declaration_mode>] [<type>] <identifier> = ]switch 
{<expression> => <local_block>} 
=> <local_block> 
where: 
• Parts enclosed in square brackets ([]) can appear zero or one time, and those enclosed in curly braces ({}) can appear zero or more times. 
44 Chapter 3. Language
Pine Script™ v5 User Manual 
• <declaration_mode> is the variable’s declaration mode 
• <type> is optional, as in almost all Pine Script™ variable declarations (see types) 
• <identifier> is the variable’s name 
• <expression> can be a literal, a variable, an expression or a function call. 
• <local_block> consists of zero or more statements followed by a return value, which can be a tuple of values. It must be indented by four spaces or a tab. 
• The value assigned to the variable is the return value of the <local_block>, or na if no local block is executed. 
• The => <local_block> at the end allows you to specify a return value which acts as a default to be used when no other case in the structure is executed. 
Only one local block of a switch structure is executed. It is thus a structured switch that doesn’t fall through cases. Consequently, break statements are unnecessary. 
Both forms are allowed as the value used to initialize a variable. 
As with the if structure, if no local block is exectuted, na is returned. 
`switch` with an expression 
Let’s look at an example of a switch using an expression: 
1 //@version=5 
2 indicator("Switch using an expression", "", true) 
3 
4 string maType = input.string("EMA", "MA type", options = ["EMA", "SMA", "RMA", "WMA"]) 5 int maLength = input.int(10, "MA length", minval = 2) 
6 
7 float ma = switch maType 
8 "EMA" => ta.ema(close, maLength) 
9 "SMA" => ta.sma(close, maLength) 
10 "RMA" => ta.rma(close, maLength) 
11 "WMA" => ta.wma(close, maLength) 
12 => 
13 runtime.error("No matching MA type found.") 
14 float(na) 
15 
16 plot(ma) 
Note that: 
• The expression we are switching on is the variable maType, which is of “input int” type (see here for an explanation of what the “input” qualifier is). Since it cannot change during the execution of the script, this guarantees that whichever MA type the user selects will be executing on each bar, which is a requirement for functions like ta.ema() which require a “simple int” argument for their length parameter. 
• If no matching value is found for maType, the switch executes the last local block introduced by =>, which acts as a catch-all. We generate a runtime error in that block. We also end it with float(na) so the local block returns a value whose type is compatible with that of the other local blocks in the structure, to avoid a compilation error. 
3.7. Conditional structures 45
Pine Script™ v5 User Manual 
`switch` without an expression 
This is an example of a switch structure wich does not use an exppression: 
1 //@version=5 
2 strategy("Switch without an expression", "", true) 
3 
4 bool longCondition = ta.crossover( ta.sma(close, 14), ta.sma(close, 28)) 5 bool shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28)) 
6 
7 switch 
8 longCondition => strategy.entry("Long ID", strategy.long) 
9 shortCondition => strategy.entry("Short ID", strategy.short) 
Note that: 
• We are using the switch to select the appropriate strategy order to emit, depending on whether the longCondi tion or shortCondition “bool” variables are true. 
• The building conditions of longCondition and shortCondition are exclusive. While they can both be false simultaneously, they cannot be true at the same time. The fact that only one local block of the switch structure is ever executed is thus not an issue for us. 
• We evaluate the calls to ta.crossover() and ta.crossunder() prior to entry in the switch structure. Not doing so, as in the following example, would prevent the functions to be executed on each bar, which would result in a compiler warning and erratic behavior: 
1 //@version=5 
2 strategy("Switch without an expression", "", true) 
3 
4 switch 
5 // Compiler warning! Will not calculate correctly! 
6 ta.crossover( ta.sma(close, 14), ta.sma(close, 28)) => strategy.entry("Long ID",␣ →strategy.long) 
7 ta.crossunder(ta.sma(close, 14), ta.sma(close, 28)) => strategy.entry("Short ID",␣ →strategy.short) 
3.7.4 Matching local block type requirement 
When multiple local blocks are used in structures, the type of the return value of all its local blocks must match. This applies only if the structure is used to assign a value to a variable in a declaration, because a variable can only have one type, and if the statement returns two incompatible types in its branches, the variable type cannot be properly determined. If the structure is not assigned anywhere, its branches can return different values. 
This code compiles fine because close and open are both of the float type: 
x = if close > open 
close 
else 
open 
This code does not compile because the first local block returns a float value, while the second one returns a string, and the result of the if-statement is assigned to the x variable: 
// Compilation error! 
x = if close > open 
(continues on next page) 
46 Chapter 3. Language
Pine Script™ v5 User Manual 
(continued from previous page) 
close 
else 
"open" 


3.8 Loops 
• Introduction 
• `for` 
• `while`
	



3.8.1 Introduction 
When loops are not needed 
Pine Script™’s runtime and its built-in functions make loops unnecessary in many situations. Budding Pine Script™ programmers not yet familiar with the Pine Script™ runtime and built-ins who want to calculate the average of the last 10 close values will often write code such as: 
1 //@version=5 
2 indicator("Inefficient MA", "", true) 
3 MA_LENGTH = 10 
4 sumOfCloses = 0.0 
5 for offset = 0 to MA_LENGTH - 1 
6 sumOfCloses := sumOfCloses + close[offset] 
7 inefficientMA = sumOfCloses / MA_LENGTH 
8 plot(inefficientMA) 
A for loop is unnecessary and inefficient to accomplish tasks like this in Pine. This is how it should be done. This code is shorter and will run much faster because it does not use a loop and uses the ta.sma() built-in function to accomplish the task: 
1 //@version=5 
2 indicator("Efficient MA", "", true) 
3 thePineMA = ta.sma(close, 10) 
4 plot(thePineMA) 
Counting the occurrences of a condition in the last bars is also a task which beginning Pine Script™ programmers often think must be done with a loop. To count the number of up bars in the last 10 bars, they will use: 
3.8. Loops 47
Pine Script™ v5 User Manual 
1 //@version=5 
2 indicator("Inefficient sum") 
3 MA_LENGTH = 10 
4 upBars = 0.0 
5 for offset = 0 to MA_LENGTH - 1 
6 if close[offset] > open[offset] 
7 upBars := upBars + 1 
8 plot(upBars) 
The efficient way to write this in Pine (for the programmer because it saves time, to achieve the fastest-loading charts, and to share our common resources most equitably), is to use the math.sum() built-in function to accomplish the task: 
1 //@version=5 
2 indicator("Efficient sum") 
3 upBars = math.sum(close > open ? 1 : 0, 10) 
4 plot(upBars) 
What’s happening in there is: 
• We use the ?: ternary operator to build an expression that yields 1 on up bars and 0 on other bars. • We use the math.sum() built-in function to keep a running sum of that value for the last 10 bars. 
When loops are necessary 
Loops exist for good reason because even in Pine Script™, they are necessary in some cases. These cases typically include: 
• The manipulation of collections (arrays, matrices, and maps). 
• Looking back in history to analyze bars using a reference value that can only be known on the current bar, e.g., to find how many past highs are higher than the high of the current bar. Since the current bar’s high is only known on the bar the script is running on, a loop is necessary to go back in time and analyze past bars. 
• Performing calculations on past bars that cannot be accomplished using built-in functions. 
3.8.2 `for` 
The for structure allows the repetitive execution of statements using a counter. Its syntax is: 
[[<declaration_mode>] [<type>] <identifier> = ]for <identifier> = <expression> to →<expression>[ by <expression>] 
<local_block_loop> 
where: 
• Parts enclosed in square brackets ([]) can appear zero or one time, and those enclosed in curly braces ({}) can appear zero or more times. 
• <declaration_mode> is the variable’s declaration mode 
• <type> is optional, as in almost all Pine Script™ variable declarations (see types) 
• <identifier> is a variable’s name 
• <expression> can be a literal, a variable, an expression or a function call. 
48 Chapter 3. Language
Pine Script™ v5 User Manual 
• <local_block_loop> consists of zero or more statements followed by a return value, which can be a tuple of values. It must be indented by four spaces or a tab. It can contain the break statement to exit the loop, or the continue statement to exit the current iteration and continue on with the next. 
• The value assigned to the variable is the return value of the <local_block_loop>, i.e., the last value calculated on the loop’s last iteration, or na if the loop is not executed. 
• The identifier in for <identifier> is the loop’s counter initial value. 
• The expression in = <expression> is the start value of the counter. 
• The expression in to <expression> is the end value of the counter. It is only evaluated upon entry in the loop. 
• The expression in by <expression> is optional. It is the step by which the loop counter is increased or decreased on each iteration of the loop. Its default value is 1 when start value < end value. It is -1 when start value > end value. The step (+1 or -1) used as the default is determined by the start and end values. 
This example uses a for statement to look back a user-defined amount of bars to determine how many bars have a high that is higher or lower than the high of the last bar on the chart. A for loop is necessary here, since the script only has access to the reference value on the chart’s last bar. Pine Script™’s runtime cannot, here, be used to calculate on the fly, as the script is executing bar to bar: 
1 //@version=5 
2 indicator("`for` loop") 
3 lookbackInput = input.int(50, "Lookback in bars", minval = 1, maxval = 4999) 4 higherBars = 0 
5 lowerBars = 0 
6 if barstate.islast 
7 var label lbl = label.new(na, na, "", style = label.style_label_left) 8 for i = 1 to lookbackInput 
9 if high[i] > high 
10 higherBars += 1 
11 else if high[i] < high 
12 lowerBars += 1 
13 label.set_xy(lbl, bar_index, high) 
14 label.set_text(lbl, str.tostring(higherBars, "# higher bars\n") + str. →tostring(lowerBars, "# lower bars")) 
This example uses a loop in its checkLinesForBreaches() function to go through an array of pivot lines and delete them when price crosses them. A loop is necessary here because all the lines in each of the hiPivotLines and loPivotLines arrays must be checked on each bar, and there is no built-in that can do this for us: 
1 //@version=5 
2 MAX_LINES_COUNT = 100 
3 indicator("Pivot line breaches", "", true, max_lines_count = MAX_LINES_COUNT) 
4 
5 color hiPivotColorInput = input(color.new(color.lime, 0), "High pivots") 6 color loPivotColorInput = input(color.new(color.fuchsia, 0), "Low pivots") 7 int pivotLegsInput = input.int(5, "Pivot legs") 
8 int qtyOfPivotsInput = input.int(50, "Quantity of last pivots to remember",␣ →minval = 0, maxval = MAX_LINES_COUNT / 2) 
9 int maxLineLengthInput = input.int(400, "Maximum line length in bars", minval = 2) 
10 
11 // ————— Queues a new element in an array and de-queues its first element. 12 qDq(array, qtyOfElements, arrayElement) => 
13 array.push(array, arrayElement) 
14 if array.size(array) > qtyOfElements 
(continues on next page) 
3.8. Loops 49
Pine Script™ v5 User Manual 
(continued from previous page) 
15 // Only deqeue if array has reached capacity. 
16 array.shift(array) 
17 
18 // —————— Loop through an array of lines, extending those that price has not crossed␣ →and deleting those crossed. 
19 checkLinesForBreaches(arrayOfLines) => 
20 int qtyOfLines = array.size(arrayOfLines) 
21 // Don't loop in case there are no lines to check because "to" value will be `na`␣ →then`. 
22 for lineNo = 0 to (qtyOfLines > 0 ? qtyOfLines - 1 : na) 
23 // Need to check that array size still warrants a loop because we may have␣ →deleted array elements in the loop. 
24 if lineNo < array.size(arrayOfLines) 
25 line currentLine = array.get(arrayOfLines, lineNo) 26 float lineLevel = line.get_price(currentLine, bar_index) 27 bool lineWasCrossed = math.sign(close[1] - lineLevel) != math.sign(close␣ →- lineLevel) 
28 bool lineIsTooLong = bar_index - line.get_x1(currentLine) >␣ →maxLineLengthInput 
29 if lineWasCrossed or lineIsTooLong 
30 // Line stays on the chart but will no longer be extend on further␣ →bars. 
31 array.remove(arrayOfLines, lineNo) 
32 // Force type of both local blocks to same type. 
33 int(na) 
34 else 
35 line.set_x2(currentLine, bar_index) 
36 int(na) 
37 
38 // Arrays of lines containing non-crossed pivot lines. 
39 var array<line> hiPivotLines = array.new_line(qtyOfPivotsInput) 
40 var array<line> loPivotLines = array.new_line(qtyOfPivotsInput) 
41 
42 // Detect new pivots. 
43 float hiPivot = ta.pivothigh(pivotLegsInput, pivotLegsInput) 
44 float loPivot = ta.pivotlow(pivotLegsInput, pivotLegsInput) 
45 
46 // Create new lines on new pivots. 
47 if not na(hiPivot) 
48 line newLine = line.new(bar_index[pivotLegsInput], hiPivot, bar_index, hiPivot,␣ →color = hiPivotColorInput) 
49 line.delete(qDq(hiPivotLines, qtyOfPivotsInput, newLine)) 
50 else if not na(loPivot) 
51 line newLine = line.new(bar_index[pivotLegsInput], loPivot, bar_index, loPivot,␣ →color = loPivotColorInput) 
52 line.delete(qDq(loPivotLines, qtyOfPivotsInput, newLine)) 
53 
54 // Extend lines if they haven't been crossed by price. 
55 checkLinesForBreaches(hiPivotLines) 
56 checkLinesForBreaches(loPivotLines) 
50 Chapter 3. Language
Pine Script™ v5 User Manual 
3.8.3 `while` 
The while structure allows the repetitive execution of statements until a condition is false. Its syntax is: 
[[<declaration_mode>] [<type>] <identifier> = ]while <expression> 
<local_block_loop> 
where: 
• Parts enclosed in square brackets ([]) can appear zero or one time. 
• <declaration_mode> is the variable’s declaration mode 
• <type> is optional, as in almost all Pine Script™ variable declarations (see types) 
• <identifier> is a variable’s name 
• <expression> can be a literal, a variable, an expression or a function call. It is evaluated at each iteration of the loop. When it evaluates to true, the loop executes. When it evaluates to false the loop stops. Note that evaluation of the expression is done before each iteration only. Changes to the expression’s value inside the loop will only have an impact on the next iteration. 
• <local_block_loop> consists of zero or more statements followed by a return value, which can be a tuple of values. It must be indented by four spaces or a tab. It can contain the break statement to exit the loop, or the continue statement to exit the current iteration and continue on with the next. 
• The value assigned to the <identifier> variable is the return value of the <local_block_loop>, i.e., the last value calculated on the loop’s last iteration, or na if the loop is not executed. 
This is the first code example of the for section written using a while structure instead of a for one: 
1 //@version=5 
2 indicator("`for` loop") 
3 lookbackInput = input.int(50, "Lookback in bars", minval = 1, maxval = 4999) 4 higherBars = 0 
5 lowerBars = 0 
6 if barstate.islast 
7 var label lbl = label.new(na, na, "", style = label.style_label_left) 8 // Initialize the loop counter to its start value. 
9 i = 1 
10 // Loop until the `i` counter's value is <= the `lookbackInput` value. 11 while i <= lookbackInput 
12 if high[i] > high 
13 higherBars += 1 
14 else if high[i] < high 
15 lowerBars += 1 
16 // Counter must be managed "manually". 
17 i += 1 
18 label.set_xy(lbl, bar_index, high) 
19 label.set_text(lbl, str.tostring(higherBars, "# higher bars\n") + str. →tostring(lowerBars, "# lower bars")) 
Note that: 
• The i counter must be incremented by one explicitly inside the while’s local block. 
• We use the += operator to add one to the counter. lowerBars += 1 is equivalent to lowerBars := lowerBars + 1. 
Let’s calculate the factorial function using a while structure: 
3.8. Loops 51
Pine Script™ v5 User Manual 
1 //@version=5 
2 indicator("") 
3 int n = input.int(10, "Factorial of", minval=0) 
4 
5 factorial(int val = na) => 
6 int counter = val 
7 int fact = 1 
8 result = while counter > 0 
9 fact := fact * counter 
10 counter := counter - 1 
11 fact 
12 
13 // Only evaluate the function on the first bar. 
14 var answer = factorial(n) 
15 plot(answer) 
Note that: 
• We use input.int() for our input because we need to specify a minval value to protect our code. While input() also supports the input of “int” type values, it does not support the minval parameter. 
• We have packaged our script’s functionality in a factorial() function which accepts as an argument the value whose factorial it must calculate. We have used int val = na to declare our function’s parameter, which says that if the function is called without an argument, as in factorial(), then the val parameter will initialize to na, which will prevent the execution of the while loop because its counter > 0 expression will return na. The while structure will thus initialize the result variable to na. In turn, because the initialization of result is the return value of the our function’s local block, the function will return na. 
• Note the last line of the while’s local block: fact. It is the local block’s return value, so the value it had on the while structure’s last iteration. 
• Our initialization of result is not required; we do it for readability. We could just as well have used: 
while counter > 0 
fact := fact * counter 
counter := counter - 1 
fact 


52 Chapter 3. Language
Pine Script™ v5 User Manual 
3.9 Type system 
• Introduction 
• Qualifiers 
• Types 
• `na` value 
• Type templates 
• Type casting 
• Tuples
	



3.9.1 Introduction 
The Pine Script™ type system determines the compatibility of a script’s values with various functions and operations. While it’s possible to write simple scripts without knowing anything about the type system, a reasonable understanding of it is necessary to achieve any degree of proficiency with the language, and an in-depth knowledge of its subtleties will allow you to harness its full potential. 
Pine Script™ uses types to classify all values, and it uses qualifiers to determine whether values are constant, established on the first script iteration, or dynamic throughout a script’s execution. This system applies to all Pine values, including those from literals, variables, expressions, function returns, and function arguments. 
The type system closely intertwines with Pine’s execution model and time series concepts. Understanding all three is essential for making the most of the power of Pine Script™. 
Note: For the sake of brevity, we often use “type” to refer to a “qualified type”. 
3.9.2 Qualifiers 
Pine Script™ qualifiers identify when a value is accessible in the script’s execution: 
• Values qualified as const are established at compile time (i.e., when saving the script in the Pine Editor or adding it to the chart). 
• Values qualified as input are available at input time (i.e., when changing values in the script’s “Settings/Inputs” tab). • Values qualified as simple are established at bar zero (the first bar of the script’s execution). • Values qualified as series can change throughout the script’s execution. 
Pine Script™ bases the dominance of type qualifiers on the following hierarchy: const < input < simple < series, where “const” is the weakest qualifier and “series” is the strongest. The qualifier hierarchy translates into this rule: whenever a variable, function, or operation is compatible with a specific qualified type, values with weaker qualifiers are also allowed. 
Scripts always qualify their expressions’ returned values based on the dominant qualifier in their calculations. For example, evaluating an expression that involves “const” and “series” values will return a value qualified as “series”. Furthermore, scripts cannot change a value’s qualifier to one that’s lower on the hierarchy. If a value acquires a stronger qualifier (e.g., a value initially inferred as “simple” becomes “series” later in the script’s execution), that state is irreversible. 
3.9. Type system 53
Pine Script™ v5 User Manual 
Note that only values qualified as “series” can change throughout the execution of a script, which include those from various built-ins, such as close and volume, as well as the results of any operations that involve “series” values. Values qualified as “const”, “input”, or “simple” are consistent throughout a script’s execution. 
const 
Values qualified as “const” are established at compile time, before the script starts its execution. Compilation initially occurs when saving a script in the Pine Editor, which does not require it to run on a chart. Values with the “const” qualifier never change between script iterations, not even on the initial bar of its execution. 
Scripts can qualify values as “const” by using a literal value or calculating values from expressions that only use literal values or other variables qualified as “const”. 
These are examples of literal values: 
• literal int: 1, -1, 42 
• literal float: 1., 1.0, 3.14, 6.02E-23, 3e8 
• literal bool: true, false 
• literal color: #FF55C6, #FF55C6ff 
• literal string: "A text literal", "Embedded single quotes 'text'", 'Embedded double quotes "text"' 
Users can explicitly define variables and parameters that only accept “const” values by including the const keyword in their declaration. 
Our Style guide recommends using uppercase SNAKE_CASE to name “const” variables for readability. While it is not a requirement, one can also use the var keyword when declaring “const” variables so the script only initializes them on the first bar of the dataset. See this section of our User Manual for more information. 
Below is an example that uses “const” values within indicator() and plot() functions, which both require a value of the “const string” qualified type as their title argument: 
1 //@version=5 
2 
3 // The following global variables are all of the "const string" qualified type: 
4 
5 //@variable The title of the indicator. 
6 INDICATOR_TITLE = "const demo" 
7 //@variable The title of the first plot. 
8 var PLOT1_TITLE = "High" 
9 //@variable The title of the second plot. 
10 const string PLOT2_TITLE = "Low" 
11 //@variable The title of the third plot. 
12 PLOT3_TITLE = "Midpoint between " + PLOT1_TITLE + " and " + PLOT2_TITLE 
13 
14 indicator(INDICATOR_TITLE, overlay = true) 
15 
16 plot(high, PLOT1_TITLE) 
17 plot(low, PLOT2_TITLE) 
18 plot(hl2, PLOT3_TITLE) 
The following example will raise a compilation error since it uses syminfo.ticker, which returns a “simple” value because it depends on chart information that’s only accessible once the script starts its execution: 
54 Chapter 3. Language
Pine Script™ v5 User Manual 
1 //@version=5 
2 
3 //@variable The title in the `indicator()` call. 
4 var NAME = "My indicator for " + syminfo.ticker 
5 
6 indicator(NAME, "", true) // Causes an error because `NAME` is qualified as a "simple␣ →string". 
7 plot(close) 
input 
Values qualified as “input” are established after initialization via the input.*() functions. These functions produce values that users can modify within the “Inputs” tab of the script’s settings. When one changes any of the values in this tab, the script re-executes from the beginning of the chart’s history to ensure its input values are consistent throughout its execution. 
Note: The input.source() function is an exception in the input.*() namespace, as it returns “series” qualified values rather than “input” since built-in variables such as open, close, etc., as well as the values from another script’s plots, are qualified as “series”. 
The following script plots the value of a sourceInput from the symbolInput and timeframeInput context. The request.security() call is valid in this script since its symbol and timeframe parameters allow “simple string” arguments, meaning they can also accept “input string” values because the “input” qualifier is lower on the hierarchy: 
1 //@version=5 
2 indicator("input demo", overlay = true) 
3 
4 //@variable The symbol to request data from. Qualified as "input string". 5 symbolInput = input.symbol("AAPL", "Symbol") 
6 //@variable The timeframe of the data request. Qualified as "input string". 7 timeframeInput = input.timeframe("D", "Timeframe") 
8 //@variable The source of the calculation. Qualified as "series float". 9 sourceInput = input.source(close, "Source") 
10 
11 //@variable The `sourceInput` value from the requested context. Qualified as "series␣ →float". 
12 requestedSource = request.security(symbolInput, timeframeInput, sourceInput) 
13 
14 plot(requestedSource) 
simple 
Values qualified as “simple” are available only once the script begins execution on the first chart bar of its history, and they remain consistent during the script’s execution. 
Users can explicitly define variables and parameters that accept “simple” values by including the simple keyword in their declaration. 
Many built-in variables return “simple” qualified values because they depend on information that a script can only obtain once it starts its execution. Additionally, many built-in functions require “simple” arguments that do not change over time. Wherever a script allows “simple” values, it can also accept values qualified as “input” or “const”. 
3.9. Type system 55
Pine Script™ v5 User Manual 
This script highlights the background to warn users that they’re using a non-standard chart type. It uses the value of chart.is_standard to calculate the isNonStandard variable, then uses that variable’s value to calculate a warning Color that also references a “simple” value. The color parameter of bgcolor() allows a “series color” argument, meaning it can also accept a “simple color” value since “simple” is lower on the hierarchy: 
1 //@version=5 
2 indicator("simple demo", overlay = true) 
3 
4 //@variable Is `true` when the current chart is non-standard. Qualified as "simple␣ →bool". 
5 isNonStandard = not chart.is_standard 
6 //@variable Is orange when the the current chart is non-standard. Qualified as →"simple color". 
7 simple color warningColor = isNonStandard ? color.new(color.orange, 70) : na 
8 
9 // Colors the chart's background to warn that it's a non-standard chart type. 10 bgcolor(warningColor, title = "Non-standard chart color") 
series 
Values qualified as “series” provide the most flexibility in scripts since they can change on any bar, even multiple times on the same bar. 
Users can explicitly define variables and parameters that accept “series” values by including the series keyword in their declaration. 
Built-in variables such as open, high, low, close, volume, time, and bar_index, and the result from any expression using such built-ins, are qualified as “series”. The result of any function or operation that returns a dynamic value will always be a “series”, as will the results from using the history-referencing operator [] to access historical values. Wherever a script allows “series” values, it will also accept values with any other qualifier, as “series” is the highest qualifier on the hierarchy. 
This script displays the highest and lowest value of a sourceInput over lengthInput bars. The values assigned to the highest and lowest variables are of the “series float” qualified type, as they can change throughout the script’s execution: 
1 //@version=5 
2 indicator("series demo", overlay = true) 
3 
4 //@variable The source value to calculate on. Qualified as "series float". 5 series float sourceInput = input.source(close, "Source") 
6 //@variable The number of bars in the calculation. Qualified as "input int". 7 lengthInput = input.int(20, "Length") 
8 
9 //@variable The highest `sourceInput` value over `lengthInput` bars. Qualified as →"series float". 
10 series float highest = ta.highest(sourceInput, lengthInput) 
11 //@variable The lowest `sourceInput` value over `lengthInput` bars. Qualified as →"series float". 
12 lowest = ta.lowest(sourceInput, lengthInput) 
13 
14 plot(highest, "Highest source", color.green) 
15 plot(lowest, "Lowest source", color.red) 
56 Chapter 3. Language
Pine Script™ v5 User Manual 
3.9.3 Types 
Pine Script™ types classify values and determine the functions and operations they’re compatible with. They include: • The fundamental types: int, float, bool, color, and string 
• The special types: plot, hline, line, linefill, box, polyline, label, table, chart.point, array, matrix, and map • User-defined types (UDTs) 
• void 
Fundamental types refer to the underlying nature of a value, e.g., a value of 1 is of the “int” type, 1.0 is of the “float” type, “AAPL” is of the “string” type, etc. Special types and user-defined types utilize IDs that refer to objects of a specific class. For example, a value of the “label” type contains an ID that acts as a pointer referring to a “label” object. The “void” type refers to the output from a function or method that does not return a usable value. 
Pine Script™ can automatically convert values from some types into others. The auto-casting rules are: int → float → bool. See the Type casting section of this page for more information. 
In most cases, Pine Script™ can automatically determine a value’s type. However, we can also use type keywords to explicitly specify types for readability and for code that requires explicit definitions (e.g., declaring a variable assigned to na). For example: 
1 //@version=5 
2 indicator("Types demo", overlay = true) 
3 
4 //@variable A value of the "const string" type for the `ma` plot's title. 5 string MA_TITLE = "MA" 
6 
7 //@variable A value of the "input int" type. Controls the length of the average. 8 int lengthInput = input.int(100, "Length", minval = 2) 
9 
10 //@variable A "series float" value representing the last `close` that crossed over␣ →the `ma`. 
11 var float crossValue = na 
12 
13 //@variable A "series float" value representing the moving average of `close`. 14 float ma = ta.sma(close, lengthInput) 
15 //@variable A "series bool" value that's `true` when the `close` crosses over the␣ →`ma`. 
16 bool crossUp = ta.crossover(close, ma) 
17 //@variable A "series color" value based on whether `close` is above or below its␣ →`ma`. 
18 color maColor = close > ma ? color.lime : color.fuchsia 
19 
20 // Update the `crossValue`. 
21 if crossUp 
22 crossValue := close 
23 
24 plot(ma, MA_TITLE, maColor) 
25 plot(crossValue, "Cross value", style = plot.style_circles) 
26 plotchar(crossUp, "Cross Up", "▲", location.belowbar, size = size.small) 3.9. Type system 57
Pine Script™ v5 User Manual 
int 
Values of the “int” type represent integers, i.e., whole numbers without any fractional quantities. Integer literals are numeric values written in decimal notation. For example: 
1 
-1 
750 
Built-in variables such as bar_index, time, timenow, dayofmonth, and strategy.wintrades all return values of the “int” type. 
float 
Values of the “float” type represent floating-point numbers, i.e., numbers that can contain whole and fractional quantities. 
Floating-point literals are numeric values written with a . delimiter. They may also contain the symbol e or E (which means “10 raised to the power of X”, where X is the number after the e or E symbol). For example: 
3.14159 // Rounded value of Pi (π) 
- 3.0 
6.02e23 // 6.02 * 10^23 (a very large value) 
1.6e-19 // 1.6 * 10^-19 (a very small value) 
The internal precision of “float” values in Pine Script™ is 1e-16. 
Built-in variables such as close, hlcc4, volume, ta.vwap, and strategy.position_size all return values of the “float” type. 
bool 
Values of the “bool” type represent the truth value of a comparison or condition, which scripts can use in conditional structures and other expressions. 
There are only two literals that represent boolean values: 
true // true value 
false // false value 
When an expression of the “bool” type returns na, scripts treat its value as false when evaluating conditional statements and operators. 
Built-in variables such as barstate.isfirst, chart.is_heikinashi, session.ismarket, and timeframe.isdaily all return values of the “bool” type. 
color 
Color literals have the following format: #RRGGBB or #RRGGBBAA. The letter pairs represent hexadecimal values be tween 00 and FF (0 to 255 in decimal) where: 
• RR, GG and BB pairs respectively represent the values for the color’s red, green and blue components. 
• AA is an optional value for the color’s opacity (or alpha component) where 00 is invisible and FF opaque. When the literal does not include an AA pair, the script treats it as fully opaque (the same as using FF). 
• The hexadecimal letters in the literals can be uppercase or lowercase. 
58 Chapter 3. Language
Pine Script™ v5 User Manual 
These are examples of “color” literals: 
#000000 // black color 
#FF0000 // red color 
#00FF00 // green color 
#0000FF // blue color 
#FFFFFF // white color 
#808080 // gray color 
#3ff7a0 // some custom color 
#FF000080 // 50% transparent red color 
#FF0000ff // same as #FF0000, fully opaque red color 
#FF000000 // completely transparent red color 
Pine Script™ also has built-in color constants, including color.green, color.red, color.orange, color.blue (the default color in plot*() functions and many of the default color-related properties in drawing types), etc. 
When using built-in color constants, it is possible to add transparency information to them via the color.new() function. 
Note that when specifying red, green or blue components in color.*() functions, we use “int” or “float” arguments with values between 0 and 255. When specifying transparency, we use a value between 0 and 100, where 0 means fully opaque and 100 means completely transparent. For example: 
1 //@version=5 
2 indicator("Shading the chart's background", overlay = true) 
3 
4 //@variable A "const color" value representing the base for each day's color. 5 color BASE_COLOR = color.rgb(0, 99, 165) 
6 
7 //@variable A "series int" value that modifies the transparency of the `BASE_COLOR`␣ →in `color.new()`. 
8 int transparency = 50 + int(40 * dayofweek / 7) 
9 
10 // Color the background using the modified `BASE_COLOR`. 
11 bgcolor(color.new(BASE_COLOR, transparency)) 
See the User Manual’s page on colors for more information on using colors in scripts. 
string 
Values of the “string” type represent sequences of letters, numbers, symbols, spaces, and other characters. String literals in Pine are characters enclosed in single or double quotation marks. For example: 
"This is a string literal using double quotes." 
'This is a string literal using single quotes.' 
Single and double quotation marks are functionally equivalent in Pine Script™. A “string” enclosed within double quo tation marks can contain any number of single quotation marks and vice versa: 
"It's an example" 
'The "Star" indicator' 
Scripts can escape the enclosing delimiter in a “string” using the backslash character (\). For example: 
'It\'s an example' 
"The \"Star\" indicator" 
3.9. Type system 59
Pine Script™ v5 User Manual 
We can create “string” values containing the new line escape character (\n) for displaying multi-line text with plot*() and log.*() functions and objects of drawing types. For example: 
"This\nString\nHas\nOne\nWord\nPer\nLine" 
We can use the + operator to concatenate “string” values: 
"This is a " + "concatenated string." 
The built-ins in the str.*() namespace create “string” values using specialized operations. For instance, this script creates a formatted string to represent “float” price values and displays the result using a label: 
1 //@version=5 
2 indicator("Formatted string demo", overlay = true) 
3 
4 //@variable A "series string" value representing the bar's OHLC data. 5 string ohlcString = str.format("Open: {0}\nHigh: {1}\nLow: {2}\nClose: {3}", open,␣ →high, low, close) 
6 
7 // Draw a label containing the `ohlcString`. 
8 label.new(bar_index, high, ohlcString, textcolor = color.white) 
See our User Manual’s page on Text and shapes for more information about displaying “string” values from a script. Built-in variables such as syminfo.tickerid, syminfo.currency, and timeframe.period return values of the “string” type. 
plot and hline 
Pine Script™’s plot() and hline() functions return IDs that respectively reference instances of the “plot” and “hline” types. These types display calculated values and horizontal levels on the chart, and one can assign their IDs to variables for use with the built-in fill() function. 
For example, this script plots two EMAs on the chart and fills the space between them using the fill() function: 
1 //@version=5 
2 indicator("plot fill demo", overlay = true) 
3 
4 //@variable A "series float" value representing a 10-bar EMA of `close`. 5 float emaFast = ta.ema(close, 10) 
6 //@variable A "series float" value representing a 20-bar EMA of `close`. 7 float emaSlow = ta.ema(close, 20) 
8 
9 //@variable The plot of the `emaFast` value. 
10 emaFastPlot = plot(emaFast, "Fast EMA", color.orange, 3) 
11 //@variable The plot of the `emaSlow` value. 
12 emaSlowPlot = plot(emaSlow, "Slow EMA", color.gray, 3) 
13 
14 // Fill the space between the `emaFastPlot` and `emaSlowPlot`. 
15 fill(emaFastPlot, emaSlowPlot, color.new(color.purple, 50), "EMA Fill") 
It’s important to note that unlike other special types, there is no plot or hline keyword in Pine to explicitly declare a variable’s type as “plot” or “hline”. 
Users can control where their scripts’ plots display via the variables in the display.* namespace. Additionally, one script can use the values from another script’s plots as external inputs via the input.source()function (see our User Manual’s section on source inputs). 
60 Chapter 3. Language
Pine Script™ v5 User Manual 
Drawing types 
Pine Script™ drawing types allow scripts to create custom drawings on charts. They include the following: line, linefill, box, polyline, label, and table. 
Each type also has a namespace containing all the built-ins that create and manage drawing instances. For example, the following *.new() constructors create new objects of these types in a script: line.new(), linefill.new(), box.new(), polyline.new(), label.new(), and table.new(). 
Each of these functions returns an ID which is a reference that uniquely identifies a drawing object. IDs are always qualified as “series”, meaning their qualified types are “series line”, “series label”, etc. Drawing IDs act like pointers, as each ID references a specific instance of a drawing in all the functions from that drawing’s namespace. For instance, the ID of a line returned by a line.new() call is used later to refer to that specific object once it’s time to delete it with line.delete(). 
Chart points 
Chart points are special types that represent coordinates on the chart. Scripts use the information from chart.point objects to determine the chart locations of lines, boxes, polylines, and labels. 
Objects of this type contain three fields: time, index, and price. Whether a drawing instance uses the time or price field from a chart.point as an x-coordinate depends on the drawing’s xloc property. 
We can use any of the following functions to create chart points in a script: 
• chart.point.new() - Creates a new chart.point with a specified time, index, and price. 
• chart.point.now() - Creates a new chart.point with a specified price y-coordinate. The time and index fields contain the time and bar_index of the bar the function executes on. 
• chart.point_from_index() - Creates a new chart.point with an index x-coordinate and price y-coordinate. The time field of the resulting instance is na, meaning it will not work with drawing objects that use an xloc value of xloc.bar_time. 
• chart.point.from_time() - Creates a new chart.point with a time x-coordinate and price y-coordinate. The index field of the resulting instance is na, meaning it will not work with drawing objects that use an xloc value of xloc.bar_index. 
• chart.point.copy() - Creates a new chart.point containing the same time, index, and price information as the id in the function call. 
This example draws lines connecting the previous bar’s high to the current bar’s low on each chart bar. It also displays labels at both points of each line. The line and labels get their information from the firstPoint and secondPoint variables, which reference chart points created using chart.point_from_index() and chart.point.now(): 
1 //@version=5 
2 indicator("Chart points demo", overlay = true) 
3 
4 //@variable A new `chart.point` at the previous `bar_index` and `high`. 5 firstPoint = chart.point.from_index(bar_index - 1, high[1]) 
6 //@variable A new `chart.point` at the current bar's `low`. 
7 secondPoint = chart.point.now(low) 
8 
9 // Draw a new line connecting coordinates from the `firstPoint` and `secondPoint`. 10 // This line uses the `index` fields from the points as x-coordinates. 11 line.new(firstPoint, secondPoint, color = color.purple, width = 3) 12 // Draw a label at the `firstPoint`. Uses the point's `index` field as its x- →coordinate. 
13 label.new( 
14 firstPoint, str.tostring(firstPoint.price), color = color.green, (continues on next page) 
3.9. Type system 61
Pine Script™ v5 User Manual 
(continued from previous page) 
15 style = label.style_label_down, textcolor = color.white 
16 ) 
17 // Draw a label at the `secondPoint`. Uses the point's `index` field as its x- →coordinate. 
18 label.new( 
19 secondPoint, str.tostring(secondPoint.price), color = color.red, 20 style = label.style_label_up, textcolor = color.white 
21 ) 
Collections 
Collections in Pine Script™ (arrays, matrices, and maps) utilize reference IDs, much like other special types (e.g., labels). The type of the ID defines the type of elements the collection will contain. In Pine, we specify array, matrix, and map types by appending a type template to the array, matrix, or map keywords: 
• array<int> defines an array containing “int” elements. 
• array<label> defines an array containing “label” IDs. 
• array<UDT> defines an array containing IDs referencing objects of a user-defined type (UDT). • matrix<float> defines a matrix containing “float” elements. 
• matrix<UDT> defines a matrix containing IDs referencing objects of a user-defined type (UDT). • map<string, float> defines a map containing “string” keys and “float” values. 
• map<int, UDT> defines a map containing “int” keys and IDs of user-defined type (UDT) instances as values. For example, one can declare an “int” array with a single element value of 10 in any of the following, equivalent ways: 
a1 = array.new<int>(1, 10) 
array<int> a2 = array.new<int>(1, 10) 
a3 = array.from(10) 
array<int> a4 = array.from(10) 
Note that: 
• The int[] syntax can also specify an array of “int” elements, but its use is discouraged. No equivalent exists to specify the types of matrices or maps in that way. 
• Type-specific built-ins exist for arrays, such as array.new_int(), but the more generic array.new<type> form is preferred, which would be array.new<int>() to create an array of “int” elements. 
User-defined types 
The type keyword allows the creation of user-defined types (UDTs) from which scripts can create objects. UDTs are composite types; they contain an arbitrary number of fields that can be of any type, including other user-defined types. The syntax to define a user-defined type is: 
[export] type <UDT_identifier> 
<field_type> <field_name> [= <value>] 
... 
where: 
• export is the keyword that a library script uses to export the user-defined type. To learn more about exporting UDTs, see our User Manual’s Libraries page. 
62 Chapter 3. Language
Pine Script™ v5 User Manual 
• <UDT_identifier> is the name of the user-defined type. 
• <field_type> is the type of the field. 
• <field_name> is the name of the field. 
• <value> is an optional default value for the field, which the script will assign to it when creating new objects of that UDT. If one does not provide a value, the field’s default is na. The same rules as those governing the default values of parameters in function signatures apply to the default values of fields. For example, a UDT’s default values cannot use results from the history-referencing operator [] or expressions. 
This example declares a pivotPoint UDT with an “int” pivotTime field and a “float” priceLevel field that will respectively hold time and price information about a calculated pivot: 
//@type A user-defined type containing pivot information. //@field pivotTime Contains time information about the pivot. 
//@field priceLevel Contains price information about the pivot. 
type pivotPoint 
int pivotTime 
float priceLevel 
User-defined types support type recursion, i.e., the fields of a UDT can reference objects of the same UDT. Here, we’ve added a nextPivot field to our previous pivotPoint type that references another pivotPoint instance: 
//@type A user-defined type containing pivot information. //@field pivotTime Contains time information about the pivot. 
//@field priceLevel Contains price information about the pivot. 
//@field nextPivot A `pivotPoint` instance containing additional pivot information. type pivotPoint 
int pivotTime 
float priceLevel 
pivotPoint nextPivot 
Scripts can use two built-in methods to create and copy UDTs: new() and copy(). See our User Manual’s page on Objects to learn more about working with UDTs. 
void 
There is a “void” type in Pine Script™. Functions having only side-effects and returning no usable result return the “void” type. An example of such a function is alert(); it does something (triggers an alert event), but it returns no usable value. 
Scripts cannot use “void” results in expressions or assign them to variables. No void keyword exists in Pine Script™ since one cannot declare a variable of the “void” type. 
3.9.4 `na` value 
There is a special value in Pine Script™ called na, which is an acronym for not available. We use na to represent an undefined value from a variable or expression. It is similar to null in Java and None in Python. 
Scripts can automatically cast na values to almost any type. However, in some cases, the compiler cannot infer the type associated with an na value because more than one type-casting rule may apply. For example: 
// Compilation error! 
myVar = na 
3.9. Type system 63
Pine Script™ v5 User Manual 
The above line of code causes a compilation error because the compiler cannot determine the nature of the myVar variable, i.e., whether the variable will reference numeric values for plotting, string values for setting text in a label, or other values for some other purpose later in the script’s execution. 
To resolve such errors, we must explicitly declare the type associated with the variable. Suppose the myVar variable will reference “float” values in subsequent script iterations. We can resolve the error by declaring the variable with the float keyword: 
float myVar = na 
or by explicitly casting the na value to the “float” type via the float() function: 
myVar = float(na) 
To test if the value from a variable or expression is na, we call the na() function, which returns true if the value is undefined. For example: 
//@variable Is 0 if the `myVar` is `na`, `close` otherwise. 
float myClose = na(myVar) ? 0 : close 
Do not use the == comparison operator to test for na values, as scripts cannot determine the equality of an undefined value: 
//@variable Returns the `close` value. The script cannot compare the equality of `na`␣ →values, as they're undefined. 
float myClose = myVar == na ? 0 : close 
Best coding practices often involve handling na values to prevent undefined values in calculations. For example, this line of code checks if the close value on the current bar is greater than the previous bar’s value: 
//@variable Is `true` when the `close` exceeds the last bar's `close`, `false`␣ →otherwise. 
bool risingClose = close > close[1] 
On the first chart bar, the value of risingClose is na since there is no past close value to reference. 
We can ensure the expression also returns an actionable value on the first bar by replacing the undefined past value with a value from the current bar. This line of code uses the nz() function to replace the past bar’s close with the current bar’s open when the value is na: 
//@variable Is `true` when the `close` exceeds the last bar's `close` (or the current␣ →`open` if the value is `na`). 
bool risingClose = close > nz(close[1], open) 
Protecting scripts against na instances helps to prevent undefined values from propagating in a calculation’s results. For example, this script declares an allTimeHigh variable on the first bar. It then uses the math.max() between the allTimeHigh and the bar’s high to update the allTimeHigh throughout its execution: 
1 //@version=5 
2 indicator("na protection demo", overlay = true) 
3 
4 //@variable The result of calculating the all-time high price with an initial value␣ →of `na`. 
5 var float allTimeHigh = na 
6 
7 // Reassign the value of the `allTimeHigh`. 
8 // Returns `na` on all bars because `math.max()` can't compare the `high` to an␣ (continues on next page) 
64 Chapter 3. Language
Pine Script™ v5 User Manual 
(continued from previous page) 
→undefined value. 
9 allTimeHigh := math.max(allTimeHigh, high) 
10 
11 plot(allTimeHigh) // Plots `na` on all bars. 
This script plots a value of na on all bars, as we have not included any na protection in the code. To fix the behavior and plot the intended result (i.e., the all-time high of the chart’s prices), we can use nz() to replace na values in the allTimeHigh series: 
1 //@version=5 
2 indicator("na protection demo", overlay = true) 
3 
4 //@variable The result of calculating the all-time high price with an initial value␣ →of `na`. 
5 var float allTimeHigh = na 
6 
7 // Reassign the value of the `allTimeHigh`. 
8 // We've used `nz()` to prevent the initial `na` value from persisting throughout the␣ →calculation. 
9 allTimeHigh := math.max(nz(allTimeHigh), high) 
10 
11 plot(allTimeHigh) 
3.9.5 Type templates 
Type templates specify the data types that collections (arrays, matrices, and maps) can contain. 
Templates for arrays and matrices consist of a single type identifier surrounded by angle brackets, e.g., <int>, <label>, and <PivotPoint> (where PivotPoint is a user-defined type (UDT)). 
Templates for maps consist of two type identifiers enclosed in angle brackets, where the first specifies the type of keys in each key-value pair, and the second specifies the value type. For example, <string, float> is a type template for a map that holds string keys and float values. 
Users can construct type templates from: 
• Fundamental types: int, float, bool, color, and string 
• The following special types: line, linefill, box, polyline, label, table, and chart.point 
• User-defined types (UDTs) 
Note that: 
• Maps can use any of these types as values, but they can only accept fundamental types as keys. 
Scripts use type templates to declare variables that point to collections, and when creating new collection instances. For example: 
1 //@version=5 
2 indicator("Type templates demo") 
3 
4 //@variable A variable initially assigned to `na` that accepts arrays of "int" values. 5 array<int> intArray = na 
6 //@variable An empty matrix that holds "float" values. 
7 floatMatrix = matrix.new<float>() 
8 //@variable An empty map that holds "string" keys and "color" values. 9 stringColorMap = map.new<string, color>() 
3.9. Type system 65
Pine Script™ v5 User Manual 
3.9.6 Type casting 
Pine Script™ includes an automatic type-casting mechanism that casts (converts) “int” values to “float” when necessary. Variables or expressions requiring “float” values can also use “int” values because any integer can be represented as a floating point number with its fractional part equal to 0. 
For the sake of backward compatibility, Pine Script™ also automatically casts “int” and “float” values to “bool” when necessary. When passing numeric values to the parameters of functions and operations that expect “bool” types, Pine auto-casts them to “bool”. However, we do not recommend relying on this behavior. Most scripts that automatically cast numeric values to the “bool” type will produce a compiler warning. One can avoid the compiler warning and promote code readability by using the bool() function, which explicitly casts a numeric value to the “bool” type. 
When casting an “int” or “float” to “bool”, a value of 0 converts to false and any other numeric value always converts to true. 
This code below demonstrates deprecated auto-casting behavior in Pine. It creates a randomValue variable with a “series float” value on every bar, which it passes to the condition parameter in an if structure and the series parameter in a plotchar() function call. Since both parameters accept “bool” values, the script automatically casts the randomValue to “bool” when evaluating them: 
1 //@version=5 
2 indicator("Auto-casting demo", overlay = true) 
3 
4 //@variable A random rounded value between -1 and 1. 
5 float randomValue = math.round(math.random(-1, 1)) 
6 //@variable The color of the chart background. 
7 color bgColor = na 
8 
9 // This raises a compiler warning since `randomValue` is a "float", but `if` expects␣ →a "bool". 
10 if randomValue 
11 bgColor := color.new(color.blue, 60) 
12 // This does not raise a warning, as the `bool()` function explicitly casts the␣ →`randomValue` to "bool". 
13 if bool(randomValue) 
14 bgColor := color.new(color.blue, 60) 
15 
16 // Display unicode characters on the chart based on the `randomValue`. 17 // Whenever `math.random()` returns 0, no character will appear on the chart because␣ →0 converts to `false`. 
18 plotchar(randomValue) 
19 // We recommend explicitly casting the number with the `bool()` function to make the␣ →type transformation more obvious. 
20 plotchar(bool(randomValue)) 
21 
22 // Highlight the background with the `bgColor`. 
23 bgcolor(bgColor) 
It’s sometimes necessary to cast one type to another when auto-casting rules do not suffice. For such cases, the following type-casting functions are available: int(), float(), bool(), color(), string(), line(), linefill(), label(), box(), and table(). 
The example below shows a code that tries to use a “const float” value as the length argument in the ta.sma() function call. The script will fail to compile, as it cannot automatically convert the “float” value to the required “int” type: 
1 //@version=5 
2 indicator("Explicit casting demo", overlay = true) 
3 
4 //@variable The length of the SMA calculation. Qualified as "const float". (continues on next page) 
66 Chapter 3. Language
Pine Script™ v5 User Manual 
(continued from previous page) 
5 float LENGTH = 10.0 
6 
7 float sma = ta.sma(close, LENGTH) // Compilation error. The `length` parameter␣ →requires an "int" value. 
8 
9 plot(sma) 
The code raises the following error: “Cannot call ‘ta.sma’ with argument ‘length’=’LENGTH’. An argument of ‘const float’ type was used but a ‘series int’ is expected.” 
The compiler is telling us that the code is using a “float” value where an “int” is required. There is no auto-casting rule to cast a “float” to an “int”, so we must do the job ourselves. In this version of the code, we’ve used the int() function to explicitly convert our “float” LENGTH value to the “int” type within the ta.sma() call: 
1 //@version=5 
2 indicator("explicit casting demo") 
3 
4 //@variable The length of the SMA calculation. Qualified as "const float". 5 float LENGTH = 10.0 
6 
7 float sma = ta.sma(close, int(LENGTH)) // Compiles successfully since we've converted␣ →the `LENGTH` to "int". 
8 
9 plot(sma) 
Explicit type casting is also handy when declaring variables assigned to na, as explained in the previous section. 
For example, once could explicitly declare a variable with a value of na as a “label” type in either of the following, equivalent ways: 
// Explicitly specify that the variable references "label" objects: 
label myLabel = na 
// Explicitly cast the `na` value to the "label" type: 
myLabel = label(na) 
3.9.7 Tuples 
A tuple is a comma-separated set of expressions enclosed in brackets. When a function, method, or other local block returns more than one value, scripts return those values in the form of a tuple. 
For example, the following user-defined function returns the sum and product of two “float” values: 
//@function Calculates the sum and product of two values. 
calcSumAndProduct(float a, float b) => 
//@variable The sum of `a` and `b`. 
float sum = a + b 
//@variable The product of `a` and `b`. 
float product = a * b 
// Return a tuple containing the `sum` and `product`. 
[sum, product] 
When we call this function later in the script, we use a tuple declaration to declare multiple variables corresponding to the values returned by the function call: 
3.9. Type system 67
Pine Script™ v5 User Manual 
// Declare a tuple containing the sum and product of the `high` and `low`,␣ →respectively. 
[hlSum, hlProduct] = calcSumAndProduct(high, low) 
Keep in mind that unlike declaring single variables, we cannot explicitly define the types the tuple’s variables (hlSum and hlProduct in this case), will contain. The compiler automatically infers the types associated with the variables in a tuple. 
In the above example, the resulting tuple contains values of the same type (“float”). However, it’s important to note that tuples can contain values of multiple types. For example, the chartInfo() function below returns a tuple containing “int”, “float”, “bool”, “color”, and “string” values: 
//@function Returns information about the current chart. 
chartInfo() => 
//@variable The first visible bar's UNIX time value. 
int firstVisibleTime = chart.left_visible_bar_time 
//@variable The `close` value at the `firstVisibleTime`. 
float firstVisibleClose = ta.valuewhen(ta.cross(time, firstVisibleTime), close, 0) //@variable Is `true` when using a standard chart type, `false` otherwise. bool isStandard = chart.is_standard 
//@variable The foreground color of the chart. 
color fgColor = chart.fg_color 
//@variable The ticker ID of the current chart. 
string symbol = syminfo.tickerid 
// Return a tuple containing the values. 
[firstVisibleTime, firstVisibleClose, isStandard, fgColor, symbol] 
Tuples are especially handy for requesting multiple values in one request.security() call. 
For instance, this roundedOHLC() function returns a tuple containing OHLC values rounded to the nearest prices that are divisible by the symbol’s minimum tick value. We call this function as the expression argument in re quest.security() to request a tuple containing daily OHLC values: 
//@function Returns a tuple of OHLC values, rounded to the nearest tick. roundedOHLC() => 
[math.round_to_mintick(open), math.round_to_mintick(high), math.round_to_ →mintick(low), math.round_to_mintick(close)] 
[op, hi, lo, cl] = request.security(syminfo.tickerid, "D", roundedOHLC()) 
We can also achieve the same result by directly passing a tuple of rounded values as the expression in the re quest.security() call: 
[op, hi, lo, cl] = request.security( 
syminfo.tickerid, "D", 
[math.round_to_mintick(open), math.round_to_mintick(high), math.round_to_ →mintick(low), math.round_to_mintick(close)] 
) 
Local blocks of conditional structures, including if and switch statements, can return tuples. For example: 
[v1, v2] = if close > open 
[high, close] 
else 
[close, low] 
and: 
68 Chapter 3. Language
